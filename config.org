* Emacs Config
** Let's get bootstrapped
*** Turn on debug
#+BEGIN_SRC emacs-lisp :tangle yes
(setq debug-on-error t)
(setq debug-on-quit t)
#+END_SRC
*** Setup package repositories
#+BEGIN_SRC emacs-lisp :tangle yes
          (require 'cl)
          (require 'package)

          (setq package-enable-at-startup nil)

          ;; orgmode.org unfortunately does not support https
          (add-to-list 'package-archives
                       '("org" . "http://orgmode.org/elpa/") t)
          (add-to-list 'package-archives
                       '("gnu" . "https://elpa.gnu.org/packages/") t)
          (add-to-list 'package-archives
                       '("melpa-stable" . "https://stable.melpa.org/packages/") t)
          (add-to-list 'package-archives
                       '("melpa" . "https://melpa.org/packages/") t)

          (unless package--initialized (package-initialize t))

          (when (< emacs-major-version 27)
            (package-initialize))

          (setq use-package-enable-imenu-support t)

          ;; Install use-package
          (unless (package-installed-p 'use-package)
            (package-refresh-contents)
            (package-install 'use-package)) ;
        (eval-when-compile (require 'use-package))
      (require 'bind-key)

      (use-package system-packages
        :ensure t)

      ;; https://github.com/emacsorphanage/key-chord/tree/master
      (use-package key-chord
        :hook (emacs-startup . (lambda ()
    (key-chord-mode 1))))
    (use-package use-package-chords
    :ensure t)
    (use-package use-package-ensure-system-package
      :ensure t)

    ;; http://emacs.stackexchange.com/a/26513/115
    (defun modi/package-dependency-check-ignore (orig-ret)
      "Remove the `black listed packages' from ORIG-RET.
    Packages listed in the let-bound `pkg-black-list' will not be auto-installed
    even if they are found as dependencies.
    It is known that this advice is not effective when installed packages
    asynchronously using `paradox'. Below is effective on synchronous
    package installations."
      (let ((pkg-black-list '(org))
            new-ret
            pkg-name)
        ;; (message "before %S" orig-ret)
        (dolist (pkg-struct orig-ret)
          (setq pkg-name (package-desc-name pkg-struct))
          (if (member pkg-name pkg-black-list)
              (message (concat "Package `%s' will not be installed. "
                               "See `modi/package-dependency-check-ignore'.")
                       pkg-name)
            ;; (message "Package to be installed: %s" pkg-name)
            (push pkg-struct new-ret)))
        ;; Tue Apr 11 17:48:16 EDT 2017 - kmodi
        ;; It's *very* critical that the order of packages stays the same in NEW-RET
        ;; as in ORIG-RET. The `push' command flips the order, so use `reverse'
        ;; to flip the order back to the original.
        ;;   Without this step, you will get errors like below when installing
        ;; packages with dependencies:
        ;;   Debugger entered--Lisp error: (error "Unable to activate package ‘nim-mode’.
        ;;   Required package ‘flycheck-28’ is unavailable")
        (setq new-ret (reverse new-ret))
        ;; (message "after  %S" new-ret)
        new-ret))
    (advice-add 'package-compute-transaction :filter-return #'modi/package-dependency-check-ignore)

          (defvar my/did-refresh-packages nil
            "Flag for whether packages have been refreshed yet")

          ;; Utility to install a list of packages
          (defun install-pkgs (list)
            (dolist (pkg list)
              (progn
                (if (not (package-installed-p pkg))
                    (progn
                      (if (not my/did-refresh-packages)
                          (progn (package-refresh-contents)
                                 (setq my/did-refresh-packages t)))
                      (package-install pkg))))))

          ;;Pin some of the packages that go wonky if I use the bleeding edge.

          (when (boundp 'package-pinned-packages)
            (setq package-pinned-packages
                  '((org-plus-contrib                  . "org")
                    (cider                             . "melpa-stable")
                    (ac-cider                          . "melpa-stable")
                    (clojure-mode                      . "melpa-stable")
                    (clojure-mode-extra-font-locking   . "melpa-stable")
                    (company-cider                     . "melpa-stable"))))

          ;; Load use-package, used for loading packages everywhere else
          (require 'use-package nil t)
          ;; Set to t to debug package loading or nil to disable
          (setq use-package-verbose nil)
#+END_SRC
*** Display loading information
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar after-emacs-hook nil
  "Hooks to run after all of the Emacs has been loaded")

(defvar emacs-start-time (current-time)
  "Time Emacs was started.")
#+END_SRC
*** Add site-lisp directory
For custom scripts
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'load-path "~/.emacs.d/site-lisp/")
#+END_SRC
** Load them environment variables
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :ensure t
  :if (memq window-system '(mac ns x))
  :init (exec-path-from-shell-initialize))
#+END_SRC

** Internal configuration
Just copying this verbose now
#+BEGIN_SRC emacs-lisp :tangle yes
(defun find-config ()
  "Edit config.org"
  (interactive)
  (find-file "~/.emacs.d/config.org"))
(global-set-key (kbd "C-c I") 'find-config)

(use-package f
  :ensure t)
(use-package general
  :ensure t)
(setq-default
   ;;;   Use spaces and not tabs for indentation
 indent-tabs-mode nil

   ;;;   Org
 org-src-fontify-natively t ;; Fontify source blocks
 org-src-tab-acts-natively t ;; indention in src blocks should work
 )
   ;;;   Customizations go to this file
(setq custom-file "~/personal/custom.el")
(when (file-exists-p custom-file)
  (load custom-file))

(setq
   ;;;   Node.js path from nvm
 exec-path (append exec-path '("~/.nvm/versions/node/v8.11.2/bin"))

   ;;;   User details
 user-mail-address "dwnewman78@gmail.com"
 user-full-name    "Daniel Newman"

   ;;;   Follow symlinks to the actual file
 find-file-visit-truename t
 vc-follow-symlinks t

   ;;;   Jump by words separated by punctuations
 global-subword-mode t

   ;;;   Turn on every disabled function
 disabled-command-function nil

   ;;;   Use UTF-8 characters in buffer
 buffer-file-coding-system 'utf-8

   ;;;   Clipboard length
 kill-ring-max 1024

   ;;;   Sentences are separated by single space after dot(.)
 sentence-end-double-space nil

   ;;;   Don't compact font cache during GC to optimize redisplay
 inhibit-compacting-font-caches t

   ;;;   GC triggers per 7 MB increase in memory
 gc-cons-threshold 58720256

   ;;;   No bells
 ring-bell-function 'ignore
 visible-bell nil

   ;;;   Themes are safe after all
 custom-safe-themes t

   ;;;   No startup show off
 inhibit-startup-screen t

   ;;;   Show line number for any normal width line
 line-number-display-limit-width 10000000

   ;;;   Some TLS connections might have larger PRIME bits
 gnutls-min-prime-bits 4096

   ;;;   Better unique names of similar filenames and buffer-names
 uniquify-buffer-name-style 'forward

   ;;;   We can use TCP connection to connect to remote Emacs instance
 server-use-tcp t

   ;;;   Save existing interprogram clipboard text before replacing it
 save-interprogram-paste-before-kill t

   ;;;   Set REPL programs' prompt as read only
 comint-prompt-read-only t

   ;;;   Use commands when in in minibuffer
 enable-recursive-minibuffers t

   ;;;   Scroll output in *compilation* buffer
 compilation-scroll-output t

   ;;;   Scroll one line at a time no matter what
 scroll-step            1
 scroll-conservatively  10000
 mouse-wheel-scroll-amount '(1 ((shift) . 1))

   ;;;   Remember screen position after scrolling
 scroll-preserve-screen-position 'always

   ;;;   Initial scratch message is nil
 initial-scratch-message ""

   ;;;   Use directory local variables in tramp session
 enable-remote-dir-locals t

   ;;;   Backup configuration
 tramp-persistency-file-name "~/.emacs.d/.cache/tramp"
 backup-directory-alist '(("." . "~/.emacs.d/.cache/backups"))
 delete-old-versions -1
 version-control t
 vc-make-backup-files t
 auto-save-file-name-transforms '((".*" "~/.emacs.d/.cache/auto-save-list" t))
 auto-save-list-file-prefix "~/.emacs.d/.cache/auto-save-list/saves-"


   ;;;   Ido mode
 ido-enable-flex-matching t
 ido-save-directory-list-file "~/.emacs.d/.cache/ido.last"

   ;;;   Line numbers
 display-line-numbers-type 'visual
 )

(with-eval-after-load 'ox-latex
    ;;;   Set colors when exporting to latex
  (setq org-latex-listings t))

(f-mkdir "~/.emacs.d/.cache" "auto-save-list")
(f-mkdir tramp-persistency-file-name)

(fset 'yes-or-no-p 'y-or-n-p)

(blink-cursor-mode 0)

(when (file-readable-p custom-file)
  (load custom-file))

(when (file-readable-p "~/.git-tokens")
  (load-file "~/.git-tokens"))

(set-language-environment 'utf-8)
(set-default-coding-systems 'utf-8)
(set-selection-coding-system 'utf-8)
(set-locale-environment "en.UTF-8")
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

(set-frame-font "Iosevka")

(menu-bar-mode 1)
(tool-bar-mode 0)
(menu-bar-no-scroll-bar)

(column-number-mode 1)
(display-time-mode 1)

(delete-selection-mode 1)

  ;;;   Automatically change to newest version of file if edited externally
(global-auto-revert-mode t)

  ;;;   Highlight matching pairs like (), {}, [], etc.
(show-paren-mode t)

  ;;;   Enable line numbers in fundamental mode
(add-hook 'text-mode-hook 'display-line-numbers-mode)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)

(when (fboundp 'xwidget-webkit-browse-url)
  (use-package xwidget
    :ensure t
    :general
    (:keymaps 'xwidget-webkit-mode-map
              "<mouse-4>" 'xwidget-webkit-scroll-down
              "<mouse-5>" 'xwidget-webkit-scroll-up
              "<up>" 'xwidget-webkit-scroll-down
              "<down>" 'xwidget-webkit-scroll-up
              "M-w" 'xwidget-webkit-copy-selection-as-kill
              "C-c" 'xwidget-webkit-copy-selection-as-kill)
    :hook
    (window-configuration-change-hook
     . (lambda ()
         (when (equal major-mode 'xwidget-webkit-mode)
           (xwidget-webkit-adjust-size-dispatch))))
    :init
    ;; by default, xwidget reuses previous xwidget window,
    ;; thus overriding your current website, unless a prefix argument
    ;; is supplied
    ;; This function always opens a new website in a new window
    (defun xwidget-browse-url-no-reuse (url &optional session)
      (interactive
       (progn
         (require 'browse-url)
         (browse-url-interactive-arg "xwidget-webkit URL: ")))
      (xwidget-webkit-browse-url url t)))
  )

(setq recentf-max-saved-items 512
      history-length t
      history-delete-duplicates t
      recentf-save-file "~/.emacs.d/.cache/recentf"
      savehist-file "~/.emacs.d/.cache/savehist"
      save-place-file "~/.emacs.d/.cache/saveplace"
      savehist-additional-variables '(kill-ring
                                      extended-command-history
                                      global-mark-ring
                                      mark-ring
                                      regexp-search-ring
                                      search-ring))
(save-place-mode 1)
(savehist-mode 1)
(recentf-mode 1)

(defun my-comint-preoutput-read-only (text)
  (propertize text 'read-only t))

(add-hook 'comint-preoutput-filter-functions
          'my-comint-preoutput-read-only)

(defun my-comint-last-output-beg ()
  (save-excursion
    (comint-goto-process-mark)
    (while (not (or (eq (get-char-property (point) 'field) 'boundary)
                    (= (point) (point-min))))
      (goto-char (previous-char-property-change (point) (point-min))))
    (if (= (point) (point-min))
        (point)
      (1+ (point)))))

(defun my-comint-last-output-end ()
  (save-excursion
    (comint-goto-process-mark)
    (while (not (or (eq (get-char-property (point) 'font-lock-face)
                        'comint-highlight-prompt)
                    (= (point) (point-min))))
      (goto-char (previous-char-property-change (point) (point-min))))
    (let ((overlay (car (overlays-at (point)))))
      (when (and overlay (eq (overlay-get overlay 'font-lock-face)
                             'comint-highlight-prompt))
        (goto-char (overlay-start overlay))))
    (1- (point))))

(defun my-comint-clear-last-output ()
  (interactive)
  (let ((start (my-comint-last-output-beg))
        (end (my-comint-last-output-end)))
    (let ((inhibit-read-only t))
      (delete-region start end)
      (save-excursion
        (goto-char start)
        (insert (propertize "output cleared"
                            'font-lock-face 'font-lock-comment-face))))))

(defun my-shell-kill-buffer-sentinel (process event)
  (when (and (memq (process-status process) '(exit signal))
             (buffer-live-p (process-buffer process)))
    (kill-buffer)))

(defun my-kill-process-buffer-on-exit ()
  (set-process-sentinel (get-buffer-process (current-buffer))
                        #'my-shell-kill-buffer-sentinel))

(dolist (hook '(ielm-mode-hook term-exec-hook comint-exec-hook))
  (add-hook hook 'my-kill-process-buffer-on-exit))

(defun my-kill-word (arg)
  (interactive "p")
  (unless buffer-read-only
    (let ((beg (point))
          (end (save-excursion (forward-word arg) (point)))
          (point (save-excursion (goto-char
                                  (if (> arg 0)
                                      (next-single-char-property-change
                                       (point) 'read-only)
                                    (previous-single-char-property-change
                                     (point) 'read-only)))
                                 (point))))
      (unless (get-char-property (point) 'read-only)
        (if (if (> arg 0) (< point end) (> point end))
            (kill-region beg point)
          (kill-region beg end))))))

(defun my-backward-kill-word (arg)
  (interactive "p")
  (my-kill-word (- arg)))

(with-eval-after-load 'comint
  (general-define-key
   :kemaps 'comint-mode-map
   "<remap> <kill-word>" 'my-kill-word
   "<remap> <backward-kill-word>" 'my-backward-kill-word
   "C-S-l" 'my-comint-clear-last-output))

(defun my-shell-turn-echo-off ()
  (setq comint-process-echoes t))

(add-hook 'shell-mode-hook 'my-shell-turn-echo-off)

(setq hippie-expand-try-functions-list
      '(yas-hippie-try-expand
        try-expand-all-abbrevs
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-dabbrev
        try-expand-dabbrev-from-kill
        try-expand-dabbrev-all-buffers
        try-expand-list
        try-expand-line
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))

(minibuffer-depth-indicate-mode 1)

(use-package winner
  :ensure t
  :init
  (winner-mode 1))

(global-prettify-symbols-mode 1)
(add-hook 'python-mode-hook 'python-prettify-symbols)
(defun python-prettify-symbols ()
  (mapc (lambda (pair) (push pair prettify-symbols-alist))
        '(;; Syntax
          ("def" .      #x2131)
          ("not" .      #x2757)
          ("in" .       #x2208)
          ("not in" .   #x2209)
          ("return" .   #x27fc)
          ("yield" .    #x27fb)
          ("for" .      #x2200)
          ;; conditions
          ("!=" .       #x2260)
          ("<=" .       #x2264)
          (">=" .       #x2265)
          ;; Base Types
          ("int" .      #x2124)
          ("float" .    #x211d)
          ("str" .      #x1d54a)
          ("True" .     #x1d54b)
          ("False" .    #x1d53d)
          )))

(defun mplist-remove (plist prop)
  "Return a copy of a modified PLIST without PROP and its values.

  If there are multiple properties with the same keyword, only the first property
  and its values are removed."
  (let ((tail plist)
        result)
    (while (and (consp tail) (not (eq prop (car tail))))
      (push (pop tail) result))
    (when (eq prop (car tail))
      (pop tail)
      (while (and (consp tail) (not (keywordp (car tail))))
        (pop tail)))
    (while (consp tail)
      (push (pop tail) result))
    (nreverse result)))

(defun set-default-font (plists)
  "Set the font given the passed PLISTS.

  PLISTS has either the form (\"fontname\" :prop1 val1 :prop2 val2 ...)
  or is a list of such. The first font that can be found will be used.

  The return value is nil if no font was found, truthy otherwise."
  (unless (listp (car plists))
    (setq plists (list plists)))
  (catch 'break
    (dolist (plist plists)
      (when (find-font (font-spec :name (car plist)))
        (let* ((font (car plist))
               (props (cdr plist))
               (font-props (mplist-remove
                            ;; although this keyword does not exist anymore
                            ;; we keep it for backward compatibility
                            (mplist-remove props :powerline-scale)
                            :powerline-offset))
               (fontspec (apply 'font-spec :name font font-props)))
          (set-frame-font fontspec nil t)
          (push `(font . ,(frame-parameter nil 'font)) default-frame-alist)
          (pcase system-type
            (`gnu/linux
             (setq fallback-font-name "Iosevka")
             (setq fallback-font-name2 "Iosevka"))
            (`darwin
             (setq fallback-font-name "Iosevka")
             (setq fallback-font-name2 "Iosevka"))
            (`windows-nt
             (setq fallback-font-name "Iosevka")
             (setq fallback-font-name2 "Iosevka"))
            (`cygwin
             (setq fallback-font-name "Iosevka")
             (setq fallback-font-name2 "Iosevka"))
            (other
             (setq fallback-font-name nil)
             (setq fallback-font-name2 nil)))
          (when (and fallback-font-name fallback-font-name2)
            ;; remove any size or height properties in order to be able to
            ;; scale the fallback fonts with the default one (for zoom-in/out
            ;; for instance)
            (let* ((fallback-props (mplist-remove
                                    (mplist-remove font-props :size)
                                    :height))
                   (fallback-spec (apply 'font-spec
                                         :name fallback-font-name
                                         fallback-props))
                   (fallback-spec2 (apply 'font-spec
                                          :name fallback-font-name2
                                          fallback-props)))
              ;; window numbers
              (set-fontset-font "fontset-default"
                                '(#x2776 . #x2793) fallback-spec nil 'prepend)
              ;; mode-line circled letters
              (set-fontset-font "fontset-default"
                                '(#x24b6 . #x24fe) fallback-spec nil 'prepend)
              ;; mode-line additional characters
              (set-fontset-font "fontset-default"
                                '(#x2295 . #x22a1) fallback-spec nil 'prepend)
              ;; new version lighter
              (set-fontset-font "fontset-default"
                                '(#x2190 . #x2200) fallback-spec2 nil 'prepend))))
        (throw 'break t)))
    nil))

(set-default-font '("Iosevka"
                    :size 16
                    :weight normal
                    :width normal))

(require 'ansi-color)
(defun colorize-compilation-buffer ()
  "Colorize the compilation buffer with ANSI escape sequences."
  (toggle-read-only)
  (ansi-color-apply-on-region (point-min) (point-max))
  (toggle-read-only))
(add-hook 'compilation-filter-hook 'colorize-compilation-buffer)

(defun my-org-autodone (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-log-states)   ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
(add-hook 'org-after-todo-statistics-hook 'my-org-autodone)


  ;;;   Fontify exported PDF using minted
;; Include the latex-exporter
(require 'ox-latex)
;; Add minted to the defaults packages to include when exporting.
(add-to-list 'org-latex-packages-alist '("" "minted"))
;; Tell the latex export to use the minted package for source
;; code coloration.
(setq org-latex-listings 'minted)
;; Let the exporter use the -shell-escape option to let latex
;; execute external programs.
;; This obviously and can be dangerous to activate!

;; I use pdflatex instead of xelatex because that seems to work
;; much better with utf-8 files
(setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
  ;;;   end


;; No box around modeline
(defun after-init-jobs ()
  "Configurations run after Emacs starts."
  (set-face-attribute 'mode-line nil :box nil)
  (set-face-attribute 'mode-line-inactive nil :box nil)
  (remove-hook 'after-init-hook 'after-init-jobs))

(add-hook 'after-init-hook 'after-init-jobs)

#+END_SRC

** Function toget basename of a given path
#+BEGIN_SRC emacs-lisp :tangle yes
(defun basename (path)
  "Returns just the file name of the given PATH."
  (file-name-nondirectory (directory-file-name path)))
#+END_SRC

** OS Specific
Setup some variables for use in other config files
#+BEGIN_SRC emacs-lisp :tangle yes
(defconst *spell-check-support-enabled* t) ;; Enable with t if you prefer
(defconst *is-a-mac* (eq system-type 'darwin))
(defconst *is-windows* (eq system-type 'windows-nt))
(defconst *is-linux* (eq system-type 'gnu/linux))
(defconst *is-gui* (not (eq window-system nil)))
(defvar running-alternate-emacs nil)
#+END_SRC
Linux
,#+BEGIN_SRC emacs-lisp :tangle yes
(when *is-linux*
  ;; Whether to use GTK tooltips or emacs ones
  (setq x-gtk-use-system-tooltips t)
  (setq dired-listing-switches "-lFaGh1v --group-directories-first"))
#+END_SRC

Mac OSX
#+BEGIN_SRC emacs-lisp :tangle yes
(when *is-a-mac*
  (if (executable-find "gls")
      (progn
        (setq insert-directory-program "gls")
        (setq dired-listing-switches "-lFaGh1v --group-directories-first"))
    (setq dired-listing-switches "-ahlF"))
  (defun copy-from-osx ()
    "Handle copy/paste intelligently on osx."
    (let ((pbpaste (purecopy "/usr/bin/pbpaste")))
      (if (and *is-a-mac*
               (file-exists-p pbpaste))
          (let ((tramp-mode nil)
                (default-directory "~"))
            (shell-command-to-string pbpaste)))))

  (defun paste-to-osx (text &optional push)
    (let ((process-connection-type nil))
      (let ((proc (start-process "pbcopy" "*Messages*" "/usr/bin/pbcopy")))
        (process-send-string proc text)
        (process-send-eof proc))))
  (setq interprogram-cut-function 'paste-to-osx
        interprogram-paste-function 'copy-from-osx)

  (defun move-file-to-trash (file)
    "Use `trash' to move FILE to the system trash.
When using Homebrew, install it using \"brew install trash\"."
    (call-process (executable-find "trash")
                  nil 0 nil
                  file)))
#+END_SRC
** God Mode
An alternative to GAAAWWWWWWWWWWWD mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package god-mode
  :ensure t
  :config
  (god-mode)
  (global-set-key (kbd "<escape>") 'god-local-mode)
  (define-key god-local-mode-map (kbd "z") 'repeat)
  (define-key god-local-mode-map (kbd "i") 'god-local-mode)
  (defun my-update-cursor ()
  (setq cursor-type (if (or god-local-mode buffer-read-only)
                        'box
                      'bar)))

  (add-hook 'god-mode-enabled-hook 'my-update-cursor)
  (add-hook 'god-mode-disabled-hook 'my-update-cursor)
  (require 'god-mode-isearch)
  (define-key isearch-mode-map (kbd "<escape>") 'god-mode-isearch-activate)
  (define-key god-mode-isearch-map (kbd "<escape>") 'god-mode-isearch-disable)
  (global-set-key (kbd "C-x C-1") 'delete-other-windows)
  (global-set-key (kbd "C-x C-2") 'split-window-below)
  (global-set-key (kbd "C-x C-3") 'split-window-right)
  (global-set-key (kbd "C-x C-0") 'delete-window)
  )

#+END_SRC
** Which key am I using
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package which-key
  :ensure t
  :config
  (which-key-mode))
#+END_SRC
** How frequent is that key pressed
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package keyfreq
  :ensure t
  :init
  (keyfreq-mode)
  )
#+END_SRC
** Hide minor modes from modeline
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package minions
  :ensure t
  :bind ([S-down-mouse-3] . minions-minor-modes-menu)
  :hook (after-init . minions-mode))
#+END_SRC

** Show last keybind and the function in modeline for screencasts
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package keycast
  :ensure t
  :bind ("<f9> k" . keycast-mode))
#+END_SRC

** Highlight of my life
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package highlight-symbol
  :ensure t
  :bind (("M-n" . highlight-symbol-next)
         ("M-p" . highlight-symbol-prev))
  :config (highlight-symbol-nav-mode))

;; volatile-highlights: highlight specific operations like undo, yank
;; https://github.com/k-talo/volatile-highlights.el
(use-package volatile-highlights :ensure t
  :config (volatile-highlights-mode t))

;; enable hl-line-mode globally
(global-hl-line-mode)

;; rainbow-mode: colorize color names in buffers
;; https://github.com/emacsmirror/rainbow-mode/blob/master/rainbow-mode.el
(use-package rainbow-mode :ensure t
  :hook ((helpful-mode . rainbow-mode)))

;; beacon: blink the cursor whenever scrolling or switching between windows
;; https://github.com/Malabarba/beacon
(use-package beacon :ensure t
  :config
  (setq beacon-size 15)
  (beacon-mode)

  ;; don't blink in shell-mode
  (add-to-list 'beacon-dont-blink-major-modes #'comint-mode t)
  (add-to-list 'beacon-dont-blink-major-modes #'term-mode t)
  (add-to-list 'beacon-dont-blink-major-modes #'sql-interactive-mode t))

;; highlight-numbers: fontify numbers
;; https://github.com/Fanael/highlight-numbers
(use-package highlight-numbers :ensure t
  :hook ((prog-mode . highlight-numbers-mode)))

;; highlight-indent-guides: best indent guides solution for emacs
;; https://github.com/DarthFennec/highlight-indent-guides
(use-package highlight-indent-guides :ensure t
  :hook ((prog-mode . highlight-indent-guides-mode))
  :config
  (setq highlight-indent-guides-method 'character)
  (setq highlight-indent-guides-character ?\ǀ)
  (setq highlight-indent-guides-responsive 'top)

  ;; https://github.com/DarthFennec/highlight-indent-guides/issues/40
  (defun jay/cleanup-hig-strings (x)
    (remove-text-properties 0 (length x) '(highlight-indent-guides-prop nil display) x))
  (advice-add 'ivy-cleanup-string :after #'jay/cleanup-hig-strings))

;; hl-todo: Highlight TODO keywords
;; https://github.com/tarsius/hl-todo/tree/master
(use-package hl-todo :ensure t
  :config (global-hl-todo-mode))

;; enable some extra syntax highlighting for dash
(with-eval-after-load 'dash
  (dash-enable-font-lock))
#+END_SRC

** Pairs work best together
Electric pairs It's Electric
#+BEGIN_SRC emacs-lisp :tangle yes
(electric-pair-mode 1)
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-insert-bracket-pair (@left-bracket @right-bracket &optional @wrap-method)
  "Insert brackets around selection, word, at point, and maybe move cursor in between.

 ,*left-bracket and *right-bracket are strings. *wrap-method must be either 'line or 'block. 'block means between empty lines.

• if there's a region, add brackets around region.
• If *wrap-method is 'line, wrap around line.
• If *wrap-method is 'block, wrap around block.
• if cursor is at beginning of line and its not empty line and contain at least 1 space, wrap around the line.
• If cursor is at end of a word or buffer, one of the following will happen:
 xyz▮ → xyz(▮)
 xyz▮ → (xyz▮)       if in one of the lisp modes.
• wrap brackets around word if any. e.g. xy▮z → (xyz▮). Or just (▮)

URL `http://ergoemacs.org/emacs/elisp_insert_brackets_by_pair.html'
Version 2017-01-17"
  (if (use-region-p)
      (progn ; there's active region
        (let (
              ($p1 (region-beginning))
              ($p2 (region-end)))
          (goto-char $p2)
          (insert @right-bracket)
          (goto-char $p1)
          (insert @left-bracket)
          (goto-char (+ $p2 2))))
    (progn ; no text selection
      (let ($p1 $p2)
        (cond
         ((eq @wrap-method 'line)
          (setq $p1 (line-beginning-position) $p2 (line-end-position))
          (goto-char $p2)
          (insert @right-bracket)
          (goto-char $p1)
          (insert @left-bracket)
          (goto-char (+ $p2 (length @left-bracket))))
         ((eq @wrap-method 'block)
          (save-excursion
            (progn
              (if (re-search-backward "\n[ \t]*\n" nil 'move)
                  (progn (re-search-forward "\n[ \t]*\n")
                         (setq $p1 (point)))
                (setq $p1 (point)))
              (if (re-search-forward "\n[ \t]*\n" nil 'move)
                  (progn (re-search-backward "\n[ \t]*\n")
                         (setq $p2 (point)))
                (setq $p2 (point))))
            (goto-char $p2)
            (insert @right-bracket)
            (goto-char $p1)
            (insert @left-bracket)
            (goto-char (+ $p2 (length @left-bracket)))))
         ( ;  do line. line must contain space
          (and
           (eq (point) (line-beginning-position))
           ;; (string-match " " (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
           (not (eq (line-beginning-position) (line-end-position))))
          (insert @left-bracket )
          (end-of-line)
          (insert  @right-bracket))
         ((and
           (or ; cursor is at end of word or buffer. i.e. xyz▮
            (looking-at "[^-_[:alnum:]]")
            (eq (point) (point-max)))
           (not (or
                 (string-equal major-mode "xah-elisp-mode")
                 (string-equal major-mode "emacs-lisp-mode")
                 (string-equal major-mode "lisp-mode")
                 (string-equal major-mode "lisp-interaction-mode")
                 (string-equal major-mode "common-lisp-mode")
                 (string-equal major-mode "clojure-mode")
                 (string-equal major-mode "xah-clojure-mode")
                 (string-equal major-mode "scheme-mode"))))
          (progn
            (setq $p1 (point) $p2 (point))
            (insert @left-bracket @right-bracket)
            (search-backward @right-bracket )))
         (t (progn
              ;; wrap around “word”. basically, want all alphanumeric, plus hyphen and underscore, but don't want space or punctuations. Also want chinese chars
              ;; 我有一帘幽梦，不知与谁能共。多少秘密在其中，欲诉无人能懂。
              (skip-chars-backward "-_[:alnum:]")
              (setq $p1 (point))
              (skip-chars-forward "-_[:alnum:]")
              (setq $p2 (point))
              (goto-char $p2)
              (insert @right-bracket)
              (goto-char $p1)
              (insert @left-bracket)
              (goto-char (+ $p2 (length @left-bracket))))))))))

(defun xah-insert-paren ()
  (interactive)
  (xah-insert-bracket-pair "(" ")") )

(defun xah-insert-bracket ()
  (interactive)
  (xah-insert-bracket-pair "[" "]") )

(defun xah-insert-brace ()
  (interactive)
  (xah-insert-bracket-pair "{" "}") )

(defun xah-insert-double-curly-quote“” () (interactive) (xah-insert-bracket-pair "“" "”") )
(defun xah-insert-curly-single-quote‘’ () (interactive) (xah-insert-bracket-pair "‘" "’") )
(defun xah-insert-single-angle-quote‹› () (interactive) (xah-insert-bracket-pair "‹" "›") )
(defun xah-insert-double-angle-quote«» () (interactive) (xah-insert-bracket-pair "«" "»") )
(defun xah-insert-ascii-double-quote () (interactive) (xah-insert-bracket-pair "\"" "\"") )
(defun xah-insert-ascii-single-quote () (interactive) (xah-insert-bracket-pair "'" "'") )
(defun xah-insert-emacs-quote () (interactive) (xah-insert-bracket-pair "`" "'") )
(defun xah-insert-corner-bracket「」 () (interactive) (xah-insert-bracket-pair "「" "」") )
(defun xah-insert-white-corner-bracket『』 () (interactive) (xah-insert-bracket-pair "『" "』") )
(defun xah-insert-angle-bracket〈〉 () (interactive) (xah-insert-bracket-pair "〈" "〉") )
(defun xah-insert-double-angle-bracket《》 () (interactive) (xah-insert-bracket-pair "《" "》") )
(defun xah-insert-white-lenticular-bracket〖〗 () (interactive) (xah-insert-bracket-pair "〖" "〗") )
(defun xah-insert-black-lenticular-bracket【】 () (interactive) (xah-insert-bracket-pair "【" "】") )
(defun xah-insert-tortoise-shell-bracket〔〕 () (interactive) (xah-insert-bracket-pair "〔" "〕") )

(global-set-key (kbd "<f8> 7") 'xah-insert-brace) ; {}
(global-set-key (kbd "<f8> 8") 'xah-insert-paren) ; ()
(global-set-key (kbd "<f8> 9") 'xah-insert-bracket) ; []
#+END_SRC
Delete bracket pairs
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-delete-backward-char-or-bracket-text ()
  "Delete backward 1 character, but if it's a \"quote\" or bracket ()[]{}【】「」 etc, delete bracket and the inner text, push the deleted text to `kill-ring'.

What char is considered bracket or quote is determined by current syntax table.

If `universal-argument' is called first, do not delete inner text.

URL `http://ergoemacs.org/emacs/emacs_delete_backward_char_or_bracket_text.html'
Version 2017-07-02"
  (interactive)
  (if (and delete-selection-mode (region-active-p))
      (delete-region (region-beginning) (region-end))
    (cond
     ((looking-back "\\s)" 1)
      (if current-prefix-arg
          (xah-delete-backward-bracket-pair)
        (xah-delete-backward-bracket-text)))
     ((looking-back "\\s(" 1)
      (progn
        (backward-char)
        (forward-sexp)
        (if current-prefix-arg
            (xah-delete-backward-bracket-pair)
          (xah-delete-backward-bracket-text))))
     ((looking-back "\\s\"" 1)
      (if (nth 3 (syntax-ppss))
          (progn
            (backward-char )
            (xah-delete-forward-bracket-pairs (not current-prefix-arg)))
        (if current-prefix-arg
            (xah-delete-backward-bracket-pair)
          (xah-delete-backward-bracket-text))))
     (t
      (delete-char -1)))))

(defun xah-delete-backward-bracket-text ()
  "Delete the matching brackets/quotes to the left of cursor, including the inner text.

This command assumes the left of point is a right bracket, and there's a matching one before it.

What char is considered bracket or quote is determined by current syntax table.

URL `http://ergoemacs.org/emacs/emacs_delete_backward_char_or_bracket_text.html'
Version 2017-07-02"
  (interactive)
  (progn
    (forward-sexp -1)
    (mark-sexp)
    (kill-region (region-beginning) (region-end))))

(defun xah-delete-backward-bracket-pair ()
  "Delete the matching brackets/quotes to the left of cursor.

After the command, mark is set at the left matching bracket position, so you can `exchange-point-and-mark' to select it.

This command assumes the left of point is a right bracket, and there's a matching one before it.

What char is considered bracket or quote is determined by current syntax table.

URL `http://ergoemacs.org/emacs/emacs_delete_backward_char_or_bracket_text.html'
Version 2017-07-02"
  (interactive)
  (let (( $p0 (point)) $p1)
    (forward-sexp -1)
    (setq $p1 (point))
    (goto-char $p0)
    (delete-char -1)
    (goto-char $p1)
    (delete-char 1)
    (push-mark (point) t)
    (goto-char (- $p0 2))))

(defun xah-delete-forward-bracket-pairs ( &optional @delete-inner-text-p)
  "Delete the matching brackets/quotes to the right of cursor.
If *delete-inner-text-p is true, also delete the inner text.

After the command, mark is set at the left matching bracket position, so you can `exchange-point-and-mark' to select it.

This command assumes the char to the right of point is a left bracket or quote, and have a matching one after.

What char is considered bracket or quote is determined by current syntax table.

URL `http://ergoemacs.org/emacs/emacs_delete_backward_char_or_bracket_text.html'
Version 2017-07-02"
  (interactive)
  (if @delete-inner-text-p
      (progn
        (mark-sexp)
        (kill-region (region-beginning) (region-end)))
    (let (($pt (point)))
      (forward-sexp)
      (delete-char -1)
      (push-mark (point) t)
      (goto-char $pt)
      (delete-char 1))))

(global-set-key (kbd "DEL") 'xah-delete-backward-char-or-bracket-text)
#+END_SRC

Select text between Quotes/Brackets
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-select-text-in-quote ()
  "Select text between the nearest left and right delimiters.
Delimiters here includes the following chars: \"<>(){}[]“”‘’‹›«»「」『』【】〖〗《》〈〉〔〕（）
This command select between any bracket chars, not the inner text of a bracket. For example, if text is

 (a(b)c▮)

 the selected char is “c”, not “a(b)c”.

URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2016-12-18"
  (interactive)
  (let (
        ($skipChars
         (if (boundp 'xah-brackets)
             (concat "^\"" xah-brackets)
           "^\"<>(){}[]“”‘’‹›«»「」『』【】〖〗《》〈〉〔〕（）"))
        $pos
        )
    (skip-chars-backward $skipChars)
    (setq $pos (point))
    (skip-chars-forward $skipChars)
    (set-mark $pos)))
#+END_SRC
Select the current line
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-select-line ()
  "Select current line. If region is active, extend selection downward by line.
URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2017-11-01"
  (interactive)
  (if (region-active-p)
      (progn
        (forward-line 1)
        (end-of-line))
    (progn
      (end-of-line)
      (set-mark (line-beginning-position)))))

(defun xah-select-current-line ()
  "Select current line.
URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2016-07-22"
  (interactive)
  (end-of-line)
  (set-mark (line-beginning-position)))
#+END_SRC
Select Current Block of text
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-select-block ()
  "Select the current/next block of text between blank lines.
If region is active, extend selection downward by block.

URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2017-11-01"
  (interactive)
  (if (region-active-p)
      (re-search-forward "\n[ \t]*\n" nil "move")
    (progn
      (skip-chars-forward " \n\t")
      (when (re-search-backward "\n[ \t]*\n" nil "move")
        (re-search-forward "\n[ \t]*\n"))
      (push-mark (point) t t)
      (re-search-forward "\n[ \t]*\n" nil "move"))))

(defun xah-select-current-block ()
  "Select the current block of text between blank lines.

URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2017-07-02"
  (interactive)
  (progn
    (skip-chars-forward " \n\t")
    (when (re-search-backward "\n[ \t]*\n" nil "move")
      (re-search-forward "\n[ \t]*\n"))
    (push-mark (point) t t)
    (re-search-forward "\n[ \t]*\n" nil "move")))
#+END_SRC

Extend Selection
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-extend-selection ()
  "Select the current word, bracket/quote expression, or expand selection.
Subsequent calls expands the selection.

when no selection,
• if cursor is on a bracket, select whole bracketed thing including bracket
• if cursor is on a quote, select whole quoted thing including quoted
• if cursor is on the beginning of line, select the line.
• else, select current word.

when there's a selection, the selection extension behavior is still experimental.
Roughly:
• if 1 line is selected, extend to next line.
• if multiple lines is selected, extend to next line.
• if a bracketed text is selected, extend to include the outer bracket. If there's no outer, select current line.

 to line, or bracket/quoted text,
or text block, whichever is the smallest.

URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2017-01-15"
  (interactive)
  (if (region-active-p)
      (progn
        (let (($rb (region-beginning)) ($re (region-end)))
          (goto-char $rb)
          (cond
           ((looking-at "\\s(")
            (if (eq (nth 0 (syntax-ppss)) 0)
                (progn
                  (message "left bracket, depth 0.")
                  (end-of-line) ; select current line
                  (set-mark (line-beginning-position)))
              (progn
                (message "left bracket, depth not 0")
                (up-list -1 t t)
                (mark-sexp))))
           ((eq $rb (line-beginning-position))
            (progn
              (goto-char $rb)
              (let (($firstLineEndPos (line-end-position)))
                (cond
                 ((eq $re $firstLineEndPos)
                  (progn
                    (message "exactly 1 line. extend to next whole line." )
                    (forward-line 1)
                    (end-of-line)))
                 ((< $re $firstLineEndPos)
                  (progn
                    (message "less than 1 line. complete the line." )
                    (end-of-line)))
                 ((> $re $firstLineEndPos)
                  (progn
                    (message "beginning of line, but end is greater than 1st end of line" )
                    (goto-char $re)
                    (if (eq (point) (line-end-position))
                        (progn
                          (message "exactly multiple lines" )
                          (forward-line 1)
                          (end-of-line))
                      (progn
                        (message "multiple lines but end is not eol. make it so" )
                        (goto-char $re)
                        (end-of-line)))))
                 (t (error "logic error 42946" ))))))
           ((and (> (point) (line-beginning-position)) (<= (point) (line-end-position)))
            (progn
              (message "less than 1 line" )
              (end-of-line) ; select current line
              (set-mark (line-beginning-position))))
           (t (message "last resort" ) nil))))
    (progn
      (cond
       ((looking-at "\\s(")
        (message "left bracket")
        (mark-sexp)) ; left bracket
       ((looking-at "\\s)")
        (message "right bracket")
        (backward-up-list) (mark-sexp))
       ((looking-at "\\s\"")
        (message "string quote")
        (mark-sexp)) ; string quote
       ((and (eq (point) (line-beginning-position)) (not (looking-at "\n")))
        (message "beginning of line and not empty")
        (end-of-line)
        (set-mark (line-beginning-position)))
       ((or (looking-back "\\s_" 1) (looking-back "\\sw" 1))
        (message "left is word or symbol")
        (skip-syntax-backward "_w" )
        ;; (re-search-backward "^\\(\\sw\\|\\s_\\)" nil t)
        (mark-sexp))
       ((and (looking-at "\\s ") (looking-back "\\s " 1))
        (message "left and right both space" )
        (skip-chars-backward "\\s " ) (set-mark (point))
        (skip-chars-forward "\\s "))
       ((and (looking-at "\n") (looking-back "\n" 1))
        (message "left and right both newline")
        (skip-chars-forward "\n")
        (set-mark (point))
        (re-search-forward "\n[ \t]*\n")) ; between blank lines, select next text block
       (t (message "just mark sexp" )
          (mark-sexp))
       ;;
       ))))
#+END_SRC

Keybindings for selecting text
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "M-6") 'xah-select-block)
(global-set-key (kbd "M-7") 'xah-select-line)
(global-set-key (kbd "M-8") 'xah-extend-selection)
(global-set-key (kbd "M-9") 'xah-select-text-in-quote)
#+END_SRC

Move cursor to brackets
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar xah-brackets nil "string of left/right brackets pairs.")
(setq xah-brackets "()[]{}<>（）［］｛｝⦅⦆〚〛⦃⦄“”‘’‹›«»「」〈〉《》【】〔〕⦗⦘『』〖〗〘〙｢｣⟦⟧⟨⟩⟪⟫⟮⟯⟬⟭⌈⌉⌊⌋⦇⦈⦉⦊❛❜❝❞❨❩❪❫❴❵❬❭❮❯❰❱❲❳〈〉⦑⦒⧼⧽﹙﹚﹛﹜﹝﹞⁽⁾₍₎⦋⦌⦍⦎⦏⦐⁅⁆⸢⸣⸤⸥⟅⟆⦓⦔⦕⦖⸦⸧⸨⸩｟｠⧘⧙⧚⧛⸜⸝⸌⸍⸂⸃⸄⸅⸉⸊᚛᚜༺༻༼༽⏜⏝⎴⎵⏞⏟⏠⏡﹁﹂﹃﹄︹︺︻︼︗︘︿﹀︽︾﹇﹈︷︸")

(defvar xah-left-brackets '("(" "{" "[" "<" "〔" "【" "〖" "〈" "《" "「" "『" "“" "‘" "‹" "«" )
  "List of left bracket chars.")
(progn
;; make xah-left-brackets based on xah-brackets
  (setq xah-left-brackets '())
  (dotimes ($x (- (length xah-brackets) 1))
    (when (= (% $x 2) 0)
      (push (char-to-string (elt xah-brackets $x))
            xah-left-brackets)))
  (setq xah-left-brackets (reverse xah-left-brackets)))

(defvar xah-right-brackets '(")" "]" "}" ">" "〕" "】" "〗" "〉" "》" "」" "』" "”" "’" "›" "»")
  "list of right bracket chars.")
(progn
  (setq xah-right-brackets '())
  (dotimes ($x (- (length xah-brackets) 1))
    (when (= (% $x 2) 1)
      (push (char-to-string (elt xah-brackets $x))
            xah-right-brackets)))
  (setq xah-right-brackets (reverse xah-right-brackets)))
(defun xah-backward-left-bracket ()
  "Move cursor to the previous occurrence of left bracket.
The list of brackets to jump to is defined by `xah-left-brackets'.
URL `http://ergoemacs.org/emacs/emacs_navigating_keys_for_brackets.html'
Version 2015-10-01"
  (interactive)
  (re-search-backward (regexp-opt xah-left-brackets) nil t))

(defun xah-forward-right-bracket ()
  "Move cursor to the next occurrence of right bracket.
The list of brackets to jump to is defined by `xah-right-brackets'.
URL `http://ergoemacs.org/emacs/emacs_navigating_keys_for_brackets.html'
Version 2015-10-01"
  (interactive)
  (re-search-forward (regexp-opt xah-right-brackets) nil t))
(global-set-key (kbd "M-m") 'xah-backward-left-bracket)
(global-set-key (kbd "M-.") 'xah-forward-right-bracket)
#+END_SRC
Jump to matching bracket
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-goto-matching-bracket ()
  "Move cursor to the matching bracket.
If cursor is not on a bracket, call `backward-up-list'.
The list of brackets to jump to is defined by `xah-left-brackets' and `xah-right-brackets'.
URL `http://ergoemacs.org/emacs/emacs_navigating_keys_for_brackets.html'
Version 2016-11-22"
  (interactive)
  (if (nth 3 (syntax-ppss))
      (backward-up-list 1 'ESCAPE-STRINGS 'NO-SYNTAX-CROSSING)
    (cond
     ((eq (char-after) ?\") (forward-sexp))
     ((eq (char-before) ?\") (backward-sexp ))
     ((looking-at (regexp-opt xah-left-brackets))
      (forward-sexp))
     ((looking-back (regexp-opt xah-right-brackets) (max (- (point) 1) 1))
      (backward-sexp))
     (t (backward-up-list 1 'ESCAPE-STRINGS 'NO-SYNTAX-CROSSING)))))

(global-set-key (kbd "M-n") 'xah-goto-matching-bracket)
#+END_SRC
** Hydra
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hydra :ensure t)
(defhydra my/hydra nil
 "
   [_s_] Skeletons
"
 ("s" my/hydra-skeleton/body :exit t)
 ("q" nil :exit t))
;; Bind the main hyrda to M-t
(global-set-key (kbd "M-t")    'my/hydra/body)

#+END_SRC
** Smartparens
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartparens :ensure t
:config
(setq sp-ignore-modes-list (quote (minibuffer-inactive-mode
Info-mode
term-mode
org-mode
org-journal-mode
markdown-mode
ivy-occur-mode)))

;; macro to wrap the current sexp at point
(defmacro def-pairs (pairs)
`(progn
,@(cl-loop for (key . val) in pairs
collect
`(defun ,(read (concat
"wrap-with-"
(prin1-to-string key)
"s"))
(&optional arg)
(interactive "p")
(sp-wrap-with-pair ,val)))))
(def-pairs ((paren . "(")
(bracket . "[")
(brace . "{")
(single-quote . "'")
(double-quote . "\"")
(back-quote . "`")))

(bind-keys
:map smartparens-mode-map
("C-M-f" . sp-forward-sexp)
("C-M-b" . sp-backward-sexp)
("C-M-d" . sp-down-sexp)
("C-M-a" . sp-backward-down-sexp)
("C-S-d" . sp-beginning-of-sexp)
("C-S-a" . sp-end-of-sexp)
("C-M-e" . sp-up-sexp)
("C-M-u" . sp-backward-up-sexp)
("M-P" . sp-previous-sexp)
("M-N" . sp-next-sexp)
("C-M-k" . sp-kill-sexp)
("C-M-w" . sp-copy-sexp)
("M-<delete>" . sp-unwrap-sexp)
("M-<backspace>" . sp-backward-unwrap-sexp)
("C-<right>" . sp-forward-slurp-sexp)
("C-<left>" . sp-forward-barf-sexp)
("C-M-<left>" . sp-backward-slurp-sexp)
("C-M-<right>" . sp-backward-barf-sexp)
("M-D" . sp-splice-sexp)
("C-M-<delete>" . sp-splice-sexp-killing-forward)
("C-M-<backspace>" . sp-splice-sexp-killing-backward)
("C-S-<backspace>" . sp-splice-sexp-killing-around)
("C-]" . sp-select-next-thing-exchange)
("C-M-]" . sp-select-next-thing)
("C-M-SPC" . sp-mark-sexp)
("M-F" . sp-forward-symbol)
("M-B" . sp-backward-symbol)

("C-c R" . sp-rewrap-sexp)
("M-[" . sp-backward-unwrap-sexp)
("M-]" . sp-unwrap-sexp)

("C-c s j" . sp-join-sexp)
("C-c s s" . sp-split-sexp)

("C-c )" . wrap-with-parens)
("C-c ]" . wrap-with-brackets)
("C-c }" . wrap-with-braces)
("C-c '" . wrap-with-single-quotes)
("C-c \"" . wrap-with-double-quotes)
("C-c `" . wrap-with-back-quotes))

;; enable smartparens globally
(smartparens-global-mode)
(smartparens-global-strict-mode) ; only allows you to insert or delete
; brackets in pairs
(show-smartparens-global-mode +1)

(require 'smartparens-config)

;; indent with braces for C like languages
(sp-with-modes '(rust-mode
js2-mode
css-mode
web-mode
typescript-mode
c-mode
c++-mode
sh-mode
go-mode
shell-mode)
(sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
(sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC")
("* ||\n[i]" "RET"))))

(bind-key "C-c h s"
(defhydra smartparens-hydra (:hint nil)
"
_d_: down           _a_: back-down        _f_: -> sexp    _k_: hyb-kill      _c_-_a_: begin
_e_: up             _u_: back-up          _b_: <- sexp    _K_: kill          _c_-_e_: end
_[_: back-unwrap    _]_: unwrap           _r_: rewrap     _m_: mark            _j_: join
_p_: prev           _n_: next             _c_: copy       _s_: mark-thing      _|_: split
_t_: transpose      _T_: hyb-transpose    _q_: quit
"

("d" sp-down-sexp)
("e" sp-up-sexp)
("u" sp-backward-up-sexp)
("a" sp-backward-down-sexp)
("f" sp-forward-sexp)
("b" sp-backward-sexp)
("k" sp-kill-hybrid-sexp)
("t" sp-transpose-sexp)
("T" sp-transpose-hybrid-sexp)
("K" sp-kill-sexp)
("[" sp-backward-unwrap-sexp)
("]" sp-unwrap-sexp)
("r" sp-rewrap-sexp)
("p" sp-previous-sexp)
("n" sp-next-sexp)
("j" sp-join-sexp)
("|" sp-split-sexp)
("c" sp-copy-sexp)
("s" sp-select-next-thing :color blue)
("m" sp-mark-sexp :color blue)
("q" nil :color blue))
smartparens-mode-map)

(setq sp-show-pair-from-inside t)
;; show matching paren instantly
(setq sp-show-pair-delay 0.1)

;; no more pair mismatch messages
(setq sp-message-width nil)

(defun sp-strict-kill-line-or-region (&optional arg)
"Kill active region or current line."
(interactive "p")
(if (use-region-p)
(sp-kill-region (region-beginning) (region-end))
(sp-kill-whole-line)))

(bind-key* "C-w" #'sp-strict-kill-line-or-region smartparens-mode-map))
#+END_SRC
** Drop down and give me 20, Magit!
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :ensure t
  :bind
  (("C-x g" . magit-status)
   :map magit-status-mode-map
   ("q". project-kill-magit-buffers))
  :init
  (defun project-kill-magit-buffers ()
    "Kill current project's magit buffers."
    (interactive)
    (when (> (count-windows) 1)
      (delete-window))
    (let ((project-magit-buffers-regexp
           (concat
            "^magit\\(?:\\|-[a-z]*\\): \\(?:"
            (regexp-quote (basename default-directory))
            "\\|"
            (regexp-quote (basename default-directory))
            "\\)")))
      (kill-matching-buffers project-magit-buffers-regexp t t))))
#+END_SRC

** Magithub, it's the hub for Magit
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magithub
  :ensure t
  :after magit
  :config
  (magithub-feature-autoinject t)
  (setq magithub-clone-default-directory "~/gitrepo"
        magithub-dir "~/.emacs.d/.cache/magithub"))
#+END_SRC

** Fringe!
This helps visualize version changes in a file
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-gutter
  :ensure t
  :when window-system
  :defer t
  :bind (("C-x P" . git-gutter:popup-hunk)
         ("C-x p" . git-gutter:previous-hunk)
         ("C-x n" . git-gutter:next-hunk)
         ("C-c G" . git-gutter:popup-hunk))
  :diminish ""
  :init
    (add-hook 'prog-mode-hook #'git-gutter-mode)
  (add-hook 'text-mode-hook #'git-gutter-mode)
  :config
  (use-package git-gutter-fringe
    :ensure t
    :init
    (require 'git-gutter-fringe)
    (when (fboundp 'define-fringe-bitmap)
      (define-fringe-bitmap 'git-gutter-fr:added
        [224 224 224 224 224 224 224 224 224 224 224 224 224
             224 224 224 224 224 224 224 224 224 224 224 224]
        nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:modified
        [224 224 224 224 224 224 224 224 224 224 224 224 224
             224 224 224 224 224 224 224 224 224 224 224 224]
        nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:deleted
        [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
        nil nil 'center))))
#+END_SRC
** Expand Regions
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package expand-region
  :ensure t
  :bind
  (("C-=" . er/expand-region)
   ("C-+" . er/contract-region)))
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :ensure t
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :init
  (use-package ag :ensure t)
  :config
  (progn
    (projectile-mode 1)
    (setq projectile-completion-system nil)))
#+END_SRC
** Switch Windows
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package switch-window
  :ensure t
  :bind
  (("M-\\" . switch-window)))
#+END_SRC
** Multiple cursors for when things get vulgar
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package multiple-cursors
  :ensure t
  :bind
  (("C-S-c" . mc/edit-lines)
   ("M-S-<up>" . mc/mark-previous-like-this)
   ("M-<up>" . mc/skip-to-previous-like-this)
   ("M-S-<down>" . mc/mark-next-like-this)
   ("M-<down>" . mc/skip-to-next-like-this)
   ("C-c C-<" . mc/mark-all-like-this)
   ("M-S-<mouse-1>" . mc/add-cursor-on-click)
   ("M-S-<mouse-2>" . mc/add-cursor-on-click)
   ("M-S-<mouse-3>" . mc/add-cursor-on-click)))
#+END_SRC
** Undo them trees
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-tree
  :ensure t
  :init
  (global-undo-tree-mode t))
#+END_SRC
** Make help helpful
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helpful
  :ensure t
  :bind
  (("C-h f" . helpful-callable)
   ("C-h v" . helpful-variable)
   ("C-h k" . helpful-key)))
#+END_SRC
** Edit your grep
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package wgrep :ensure t)
#+END_SRC
** Doom Themes
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package doom-themes :ensure t)
(load-theme 'doom-gruvbox)
#+END_SRC
** Ewww page break characters
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package page-break-lines
  :ensure t
  :init
  (global-page-break-lines-mode t))
#+END_SRC
** Company Complete!
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :ensure t
  :bind
  (("M-/" . hippie.expand) ;; replace `dabbrev-expand' with `hippie-expand' which does a lot more
   ("C-<tab>" . company-dabbrev))
  (:map company-active-map
        ("M-p" . nil)
        ("M-n" . nil)
        ("C-m" . nil)
        ("C-h" . nil)
        ("C-n" . company-select-next)
        ("C-p" . company-select-previous)
        ("<tab>" . company-complete-common)
        ("C-t" . company-show-doc-buffer))
  :config
  (setq company-tooltip-flip-when-above t)
  (setq company-minimum-prefix-length 3)
  (setq company-idle-delay 0.2)
  (setq company-selection-wrap-around t)
  (setq company-show-numbers t)
  (setq company-require-match 'never)
  (setq company-tooltip-align-annotations t)

  ;; don't downcase results from company-dabbrev
  (setq company-dabbrev-downcase nil)
  ;; use only buffers with same major-mode for company-dabbrev
  (setq company-dabbrev-other-buffers t)

  ;; Suspend page-break-lines-mode while company menu is active
  ;; (see https://github.com/company-mode/company-mode/issues/416)
  (defvar sanityinc/page-break-lines-on-p nil)
  (make-variable-buffer-local 'sanityinc/page-break-lines-on-p)

  (defun sanityinc/page-break-lines-disable (&rest ignore)
    (when (setq sanityinc/page-break-lines-on-p (bound-and-true-p page-break-lines-mode))
      (page-break-lines-mode -1)))

  (defun sanityinc/page-break-lines-maybe-reenable (&rest ignore)
    (when sanityinc/page-break-lines-on-p
      (page-break-lines-mode 1)))

  (add-hook 'company-completion-started-hook 'sanityinc/page-break-lines-disable)
  (add-hook 'company-completion-finished-hook 'sanityinc/page-break-lines-maybe-reenable)
  (add-hook 'company-completion-cancelled-hook 'sanityinc/page-break-lines-maybe-reenable))

(use-package company-prescient
  :ensure t
  :hook (company-mode . company-prescient-mode)
  :config (prescient-persist-mode +1))
#+END_SRC
** Buffers
*** Create a new empty buffer with the press of a key!
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-new-empty-buffer ()
  "Create anew empty buffer.
New buffer will be named 'untitled' or 'untitled<2>', 'untitled<3>', etx.

It returns the buffer (for elisp programming).
URL `http://egroemacs.org/emacs.emacs_new_empty_buffer.html'
Version 2017-11-01"
  (interactive)
  (let (($buf (generate-new-buffer "untitled")))
    (switch-to-buffer $buf)
    (funcall initial-major-mode)
    (setq buffer-offer-save t)
    $buf
    ))
(global-set-key (kbd "<f7>") 'xah-new-empty-buffer)
#+END_SRC

** Flycheck vs Flyspell
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flyspell
  :ensure nil
  :hook
  ((org-mode . flyspell-mode)
   (markdown-mode . flyspell-mode)
   (prog-mode . flyspell-prog-mode))
  :config
  ;; Save a new word to personal dictionary without asking
  (setq ispell-silently-savep t)

  ;; speed up flyspell
  (setq flyspell-issue-message-flag nil)

  ;; use hunspell as the default dictionary
  (when (executable-find "hunspell")
    (setq ispell-program-name (executable-find "hunspell"))
    (setq ispell-really-hunspell t)
    (setenv "DICTIONARY" "en_US")
    (setq ispell-dictionary "en_US")))

;; flycheck: on the fly syntax checking
;; http://www.flycheck.org/en/latest/
(use-package flycheck
  :bind ("C-c h f" . hydra-flycheck/body)
  :config
  (defhydra hydra-flycheck (:color blue
                                   :hint nil)
    "
  ^
  ^Flycheck^          ^Errors^            ^Checker^
  ^────────^──────────^──────^────────────^───────^─────
  _q_ quit            _<_ previous        _?_ describe
  _M_ manual          _>_ next            _d_ disable
  _v_ verify setup    _f_ check           _m_ mode
  ^^                  _l_ list            _s_ select
  ^^                  ^^                  ^^
  "
    ("q" nil)
    ("<" flycheck-previous-error :color pink)
    (">" flycheck-next-error :color pink)
    ("?" flycheck-describe-checker)
    ("M" flycheck-manual)
    ("d" flycheck-disable-checker)
    ("f" flycheck-buffer)
    ("l" flycheck-list-errors)
    ("m" flycheck-mode)
    ("s" flycheck-select-checker)
    ("v" flycheck-verify-setup)))

;; flycheck-posframe: Show flycheck errors via posframe.el
;; https://github.com/alexmurray/flycheck-posframe
(use-package flycheck-posframe :defer t :ensure t
  :after flycheck
  :hook (flycheck-mode . flycheck-posframe-mode)
  :config (flycheck-posframe-configure-pretty-defaults))
#+END_SRC

** Language Server Protocol
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package lsp-mode
  :ensure t)

(use-package company-lsp
  :ensure t
  :config
  (push 'company-lsp company-backends))

(use-package lsp-ui
  :ensure t
  :config
  (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
  (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)
  (setq lsp-ui-sideline-enable nil
        lsp-ui-flycheck-enable t
        lsp-ui-imenu-enable t
        lsp-ui-sideline-ignore-duplicate t))

#+END_SRC

** Languages
Here is where I keep language specific config
*** Typescript
#+BEGIN_SRC emacs-lisp :tangle yes
;; typescript: major mode for editing typescript files
;; https://github.com/ananthakumaran/typescript.el
(use-package typescript-mode
:ensure t
  :hook ((typescript-mode . (lambda ()
                              (my-tide-setup-hook)
                              (add-node-modules-path)
                              (company-mode))))
  :bind ((:map typescript-mode-map
               ("C-c C-t" . tide-documentation-at-point)
               ("C-c T p" . typescript/open-region-in-playground)))
  :config
  (defun typescript/open-region-in-playground (start end)
    "Open selected region in http://www.typescriptlang.org/Playground
                 If nothing is selected - open the whole current buffer."
    (interactive (if (use-region-p)
                     (list (region-beginning) (region-end))
                   (list (point-min) (point-max))))
    (browse-url (concat "http://www.typescriptlang.org/Playground#src="
                        (url-hexify-string (buffer-substring-no-properties start end))))))

;; tide: TypeScript Interactive Development Environment for Emacs
;; https://github.com/ananthakumaran/tide
(use-package tide
:ensure t
  :after typescript-mode
  :config
  (defun my-tide-setup-hook ()
    ;; configure tide
    (tide-setup)
    ;; highlight identifiers
    (tide-hl-identifier-mode +1)
    ;;enable eldoc-mode
    (eldoc-mode)
    ;; enable flycheck
    (flycheck-mode)

    ;; format typescript files using prettier
    (prettier-js-mode)

    ;; company-backends setup
    (set (make-local-variable 'company-backends)
         '((company-tide company-files :with company-yasnippet)
           (company-dabbrev-code company-dabbrev))))

  ;; use 2 space indentation
  (setq typescript-indent-level 2)

  ;; add tslint checker for flycheck
  (flycheck-add-next-checker 'typescript-tide
                             'typescript-tslint)

  (setq tide-completion-detailed t)

  (add-hook 'tide-mode-hook
            (lambda ()
              (add-hook 'kill-buffer-hook #'+javascript|cleanup-tide-processes nil t))))

;;;###autoload
(defun +javascript|cleanup-tide-processes ()
  "Clean up dangling tsserver processes if there are no more buffers with
`tide-mode' active that belong to that server's project."
  (when tide-mode
    (unless (cl-loop with project-name = (tide-project-name)
                     for buf in (delq (current-buffer) (buffer-list))
                     if (and (buffer-local-value 'tide-mode buf)
                             (with-current-buffer buf
                               (string= (tide-project-name) project-name)))
                     return buf)
      (kill-process (tide-current-server)))))
#+END_SRC
*** Javascript
Javascript is hip
Trying out a config from [[https://github.com:CSRaghunandan/.emacs.d][CSRaghunandan]]
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package js2-mode
  :ensure t
    :mode (("\\.js$" . js2-mode))
    :hook ((js2-mode . (lambda ()
                         (flycheck-mode)
                         (my-tide-setup-hook)
                         (company-mode))))
    :config
    ;; two spaces is what everyone should use
    (setq js-indent-level 2
          js2-basic-offset 2
          js-chain-indent t)

    ;; use eslint_d instead of eslint for faster linting
    (setq flycheck-javascript-eslint-executable "eslint_d")

    ;; Try to hightlight most ECMA built-ins
    (setq js2-highlight-level 3)

      ;; turn off all warnings in js2-mode
    (setq js2-mode-show-parse-errors t)
    (setq js2-mode-show-strict-warnings nil)
    (setq js2-strict-missing-semi-warning nil)

    (defun my-tide-setup-hook ()
      ;; configure tide
      (tide-setup)
      ;; highlight identifiers
      (tide-hl-identifier-mode +1)
      ;;enable eldoc-mode
      (eldoc-mode)
      ;; enable flycheck
      (flycheck-mode)

      ;; format typescript files using prettier
      (prettier-js-mode)

      ;; company-backends setup
      (set (make-local-variable 'company-backends)
           '((company-tide company-files :with company-yasnippet)
             (company-dabbrev-code company-dabbrev)))

      ;; configure javascript-tide checker to run after your default javascript checker
      (flycheck-add-next-checker 'javascript-eslint 'javascript-tide 'append)))

  ;; js2-refactor: refactoring options for emacs
  ;; https://github.com/magnars/js2-refactor.el
  (use-package js2-refactor
  :ensure t
    :after js2-mode
    :bind
    (:map js2-mode-map
          ("C-k" . js2r-kill)
          ("C-c h r" . js2-refactor-hydra/body))
    :hook ((js2-mode . js2-refactor-mode))
    :config (js2r-add-keybindings-with-prefix "C-c C-r")

    (defhydra js2-refactor-hydra (:color blue :hint nil)
      "
  ^Functions^                    ^Variables^               ^Buffer^                      ^sexp^               ^Debugging^
  ------------------------------------------------------------------------------------------------------------------------------
  [_lp_] Localize Parameter      [_ev_] Extract variable   [_wi_] Wrap buffer in IIFE    [_k_]  js2 kill      [_lt_] log this
  [_ef_] Extract function        [_iv_] Inline variable    [_ig_] Inject global in IIFE  [_ss_] split string  [_dt_] debug this
  [_ip_] Introduce parameter     [_rv_] Rename variable    [_ee_] Expand node at point   [_sl_] forward slurp
  [_em_] Extract method          [_vt_] Var to this        [_cc_] Contract node at point [_ba_] forward barf
  [_ao_] Arguments to object     [_sv_] Split var decl.    [_uw_] unwrap
  [_tf_] Toggle fun exp and decl [_ag_] Add var to globals
  [_ta_] Toggle fun expr and =>  [_ti_] Ternary to if
  [_q_]  quit"
      ("ee" js2r-expand-node-at-point)
      ("cc" js2r-contract-node-at-point)
      ("ef" js2r-extract-function)
      ("em" js2r-extract-method)
      ("tf" js2r-toggle-function-expression-and-declaration)
      ("ta" js2r-toggle-arrow-function-and-expression)
      ("ip" js2r-introduce-parameter)
      ("lp" js2r-localize-parameter)
      ("wi" js2r-wrap-buffer-in-iife)
      ("ig" js2r-inject-global-in-iife)
      ("ag" js2r-add-to-globals-annotation)
      ("ev" js2r-extract-var)
      ("iv" js2r-inline-var)
      ("rv" js2r-rename-var)
      ("vt" js2r-var-to-this)
      ("ao" js2r-arguments-to-object)
      ("ti" js2r-ternary-to-if)
      ("sv" js2r-split-var-declaration)
      ("ss" js2r-split-string)
      ("uw" js2r-unwrap)
      ("lt" js2r-log-this)
      ("dt" js2r-debug-this)
      ("sl" js2r-forward-slurp)
      ("ba" js2r-forward-barf)
      ("k" js2r-kill)
      ("q" nil)))

  ;; prettier-emacs: minor-mode to prettify javascript files on save
  ;; https://github.com/prettier/prettier-emacs
  (use-package prettier-js
:ensure t
    :hook ((js2-mode . prettier-js-mode)
           (rjsx-mode . prettier-js-mode)))

  ;; json-snatcher: get the path of any JSON element easily
  ;; https://github.com/Sterlingg/json-snatcher
  (use-package json-snatcher
:ensure t
    :hook ((json-mode . js-mode-bindings))
    :config
    (defun js-mode-bindings ()
      "Sets a hotkey for using the json-snatcher plugin"
      (when (string-match  "\\.json$" (buffer-name))
        (local-set-key (kbd "C-c C-g") 'jsons-print-path))))

  ;; indium: javascript awesome development environment
  ;; https://github.com/NicolasPetton/indium
  (use-package indium
:ensure t
    :after js2-mode
    :bind (:map js2-mode-map
                ("C-c C-l" . indium-eval-buffer))
    :hook (((js2-mode typescript-mode) . indium-interaction-mode)))

  ;; mocha: emacs mode for running mocha tests
  ;; https://github.com/scottaj/mocha.el
  (use-package mocha
:ensure t
    :after js2-mode
    :config
    (require 'typescript-mode)
    (dolist (m (list js2-mode-map typescript-mode-map))
      (bind-keys
       :map m
       ("C-c m P" . mocha-test-project)
       ("C-c m f" . mocha-test-file)
       ("C-c m p" . mocha-test-at-point))))

  ;; mocha-snippets: snippets for mocha test framework
  ;; https://github.com/cowboyd/mocha-snippets.el
  (use-package mocha-snippets
:ensure t)

  ;; Adds the node_modules/.bin directory to the buffer exec_path. E.g. support project local eslint installations.
  ;; https://github.com/codesuki/add-node-modules-path/tree/master
  (use-package add-node-modules-path
:ensure t
    :hook ((js2-mode . add-node-modules-path)
           (rjsx-mode . add-node-modules-path)))

  ;; json-mode: Major mode for editing JSON files with emacs
  ;; https://github.com/joshwnj/json-mode
  (use-package json-mode
:ensure t
    :mode "\\.js\\(?:on\\|[hl]int\\(rc\\)?\\)\\'"
    :config
    (add-hook 'json-mode-hook #'prettier-js-mode)
    (setq json-reformat:indent-width 2)
    (setq json-reformat:pretty-string? t)
    (setq js-indent-level 2))

  ;; eslintd-fix: Emacs minor-mode to automatically fix javascript with eslint_d.
  ;; https://github.com/aaronjensen/eslintd-fix/tree/master
  (use-package eslintd-fix
:ensure t)

  ;; rjsx-mode: A JSX major mode for Emacs
  ;; https://github.com/felipeochoa/rjsx-mode
  (use-package rjsx-mode
:ensure t
    :after js2-mode
    :mode (("\\.jsx$" . rjsx-mode)
           ("components/.+\\.js$" . rjsx-mode))
    :hook (rjsx-mode . (lambda ()
                            (flycheck-mode)
                            (my-tide-setup-hook)
                            (company-mode)
                            (indium-interaction-mode -1)
                            (js2-refactor-mode -1)))
    :init
    (defun +javascript-jsx-file-p ()
      "Detect React or preact imports early in the file."
      (and buffer-file-name
           (string= (file-name-extension buffer-file-name) "js")
           (re-search-forward "\\(^\\s-*import +React\\|\\( from \\|require(\\)[\"']p?react\\)"
                              magic-mode-regexp-match-limit t)
           (progn (goto-char (match-beginning 1))
                  (not (sp-point-in-string-or-comment)))))
    (add-to-list 'magic-mode-alist '(+javascript-jsx-file-p . rjsx-mode))
    :config (unbind-key "C-c C-l" rjsx-mode-map))
#+END_SRC
*** Web mode
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package web-mode
  :mode (("\\.html$" . web-mode)
         ("\\.djhtml$" . web-mode)
         ("\\.tsx$" . web-mode)
         ("\\.mustache\\'" . web-mode)
         ("\\.phtml\\'" . web-mode)
         ("\\.as[cp]x\\'" . web-mode)
         ("\\.erb\\'" . web-mode)
         ("\\.hbs\\'" . web-mode))
  :hook ((web-mode . company-mode)
         (web-mode . (lambda ()
                       (highlight-indent-guides-mode -1))))
  :config

  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)

  (setq web-mode-enable-html-entities-fontification t
        web-mode-auto-close-style 2)

  (with-eval-after-load "smartparens"
    (defun +web-is-auto-close-style-3 (_id action _context)
      (and (eq action 'insert)
           (eq web-mode-auto-close-style 3)))
    (sp-local-pair 'web-mode "<" nil :unless '(:add +web-is-auto-close-style-3))

    ;; let smartparens handle these
    (setq web-mode-enable-auto-quoting nil
          web-mode-enable-auto-pairing t)

    ;; 1. Remove web-mode auto pairs whose end pair starts with a latter
    ;;    (truncated autopairs like <?p and hp ?>). Smartparens handles these
    ;;    better.
    ;; 2. Strips out extra closing pairs to prevent redundant characters
    ;;    inserted by smartparens.
    (dolist (alist web-mode-engines-auto-pairs)
      (setcdr alist
              (cl-loop for pair in (cdr alist)
                       unless (string-match-p "^[a-z-]" (cdr pair))
                       collect (cons (car pair)
                                     (string-trim-right (cdr pair) "\\(?:>\\|]\\|}\\)+")))))
    (setf (alist-get nil web-mode-engines-auto-pairs) nil))

  ;; highlight matching tag
  (setq web-mode-enable-current-element-highlight t)

  (defun my-tide-setup-hook ()
    ;; configure tide
    (tide-setup)
    ;;enable eldoc-mode
    (eldoc-mode)
    ;; highlight identifiers
    (tide-hl-identifier-mode +1)
    ;; enable flycheck
    (flycheck-mode)

    ;; company-backends setup
    (set (make-local-variable 'company-backends)
         '((company-tide company-files :with company-yasnippet)
           (company-dabbrev-code company-dabbrev)))

    ;; enable typescript-tslint checker
    (flycheck-add-mode 'typescript-tslint 'web-mode))

  (defun my-web-mode-hook ()
    "company hook for `web-mode' for non-html buffers."
    (set (make-local-variable 'company-backends)
         '((company-capf company-files :with company-yasnippet)
           (company-dabbrev-code company-dabbrev))))

  (defun my-lsp-html-mode-hook ()
    " company hook for `web-mode' for html buffers."
    (set (make-local-variable 'company-backends)
         '((company-lsp company-files :with company-yasnippet)
           (company-dabbrev-code company-dabbrev))))

  (defun lsp-html-setup ()
    "Function to setup `lsp-html'"
    (lsp-html-enable)
    (lsp-ui-mode)
    (my-lsp-html-mode-hook)
    (emmet-mode)
    (setq-local lsp-highlight-symbol-at-point nil)
    (bind-key "C-c o b" #'browse-url-of-file (current-local-map)))

  (add-hook 'web-mode-hook
            (lambda ()
              (pcase (file-name-extension buffer-file-name)
                ("tsx" (my-tide-setup-hook))
                ("html" (lsp-html-setup))
                (_ (my-web-mode-hook)))))

  ;; colorize colors in buffers
  (setq web-mode-enable-css-colorization t))

;; impatient mode: Live refresh of web pages
;; https://github.com/skeeto/impatient-mode
(use-package impatient-mode
  :ensure t
  :commands (impatient-mode))

;; emmet-mode: dynamic snippets for HTML
;; https://github.com/smihica/emmet-mode
(use-package emmet-mode
  :ensure t
  :bind
  ((:map emmet-mode-keymap
         ("C-c [" . emmet-prev-edit-point)
         ("C-c ]" . emmet-next-edit-point)))
  :config
  (setq emmet-move-cursor-between-quotes t)
  (setq emmet-indentation 2)
  (unbind-key "C-M-<left>" emmet-mode-keymap)
  (unbind-key "C-M-<right>" emmet-mode-keymap))
#+END_SRC
*** Python
#+BEGIN_SRC emacs-lisp :tangle yes
(setq python-shell-interpreter "ipython"
        python-shell-interpreter-args "--simple-prompt -i")
(use-package pyenv-mode
  :ensure t
  :config
  (pyenv-mode))
(use-package company-jedi :ensure t)
(use-package elpy
  :ensure t
  :config
  (elpy-enable))
(use-package eglot :ensure t)
(defun ssbb-pyenv-hook ()
  "Automatically activates pyenv version if .python-version file exists."
  (f-traverse-upwards
   (lambda (path)
     (let ((pyenv-version-path (f-expand ".python-version" path)))
       (if (f-exists? pyenv-version-path)
           (pyenv-mode-set (s-trim (f-read-text pyenv-version-path 'utf-8))))))))
(add-hook 'find-file-hook 'ssbb-pyenv-hook)
#+END_SRC
*** C and C++
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ccls
  :ensure t
  :commands lsp-ccls-enable
  :hook ((c++-mode c-mode) . ccls//enable)
  :init
  (defun ccls//enable ()
    (condition-case nil
        (lsp-ccls-enable)
      (user-error nil))))
#+END_SRC
*** Yaml mode
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yaml-mode
  :ensure t)
#+END_SRC
*** Elisp
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package elisp-mode :ensure nil
  :bind (:map emacs-lisp-mode-map
              ("C-c C-l" . eval-buffer))
  :config
  (defun my-elisp-mode-hook ()
    "Hook for `emacs-lisp-mode'"
    (set (make-local-variable 'company-backends)
         '((company-capf company-files :with company-yasnippet)
           (company-dabbrev-code company-dabbrev))))
  (add-hook 'emacs-lisp-mode-hook 'my-elisp-mode-hook)
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (defun byte-compile-current-buffer ()
    "`byte-compile' current buffer if it's emacs-lisp-mode and compiled file exists."
    (interactive)
    (when (and (eq major-mode 'emacs-lisp-mode)
               (file-exists-p (byte-compile-dest-file buffer-file-name)))
      (byte-compile-file buffer-file-name)))

  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (add-hook 'before-save-hook
                        (lambda ()
                          (time-stamp)
                          (xah-clean-whitespace)) nil t)))

  (add-hook 'after-save-hook #'byte-compile-current-buffer))

;; highlight-quoted: highlight lisp quoted and quotes symbols
;; https://github.com/Fanael/highlight-quoted
(use-package highlight-quoted
  :ensure t
  :hook ((emacs-lisp-mode lisp-mode) . highlight-quoted-mode)
  :config
  ;; Highlight the ' character itself in the same colour
  ;; as the quoted symbol.
  (set-face-attribute 'highlight-quoted-quote nil
                      :inherit 'highlight-quoted-symbol))

;; Go to the definition of the symbol at point. Supports global definitions,
;; local definitions, and even macro-heavy code!
;; https://github.com/Wilfred/elisp-def
(use-package elisp-def
  :ensure t
  :bind (:map emacs-lisp-mode-map
              ("M-." . elisp-def)
              ("M-," . xref-pop-marker-stack)))
#+END_SRC
** Smarty pants tabs
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smart-tabs-mode
    :ensure t
    :config
    (smart-tabs-insinuate 'c 'javascript 'python)
    (smart-tabs-advice python-indent-line-1 python-indent)
    (add-hook 'python-mode-hook
              (lambda ()
                (setq indent-tabs-mode t)
                (setq tab-width (default-value 'tab-width)))))
#+END_SRC
** Helm
There are many helm things. I use it a lot.

A lot of things are taken from taken from
https://tuhdo.github.io/helm-intro.html

Before we load any helm things, need to load [[https://github.com/PythonNut/helm-flx][helm-flx]] so it uses flx instead of
helm's fuzzy matching. This has to happen before helm is loaded, so it goes
here.

Now we can load the big Helm configuration. Here is a breakdown of the helm
bindings I use more frequently:

| Key     | Action                                          |
|---------+-------------------------------------------------|
| M-x     | helm meta-x                                     |
| C-x C-f | helm find files                                 |
| C-x C-d | helm browse project                             |
| C-x f   | helm projectile                                 |
| C-x C-r | helm mini (includes recentf)                    |
| C-x C-o | helm occur (search in buffer)                   |
| M-y     | helm kill ring                                  |
| C-h a   | helm appropos (search functions/vars/commands)  |
| C-h m   | helm man (man pages)                            |
| C-h SPC | helm registers                                  |
| C-x b   | helm mini                                       |
| C-h t   | helm world time (show time in different places) |
| C-x C-i | helm semantic or imenu (depending on the mode)  |


#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helm-flx
  :ensure t
  :init
  (setq helm-flx-for-helm-find-files nil)
  (helm-flx-mode 1))

(use-package helm-config
  :ensure helm
  :demand t ;; demand it be loaded!
  :diminish helm-mode
  :bind
  (("C-M-z" . helm-resume)
   ("C-x C-f" . helm-find-files)
   ("C-x C-r" . helm-mini)
   ("C-x o" . helm-occur)
   ("M-y" . helm-show-kill-ring)
   ("C-h a" . helm-apropos)
   ("C-h m" . helm-man-woman)
   ("C-h SPC" . helm-all-mark-rings)
   ("C-x C-i" . helm-semantic-or-imenu)
   ("M-x" . helm-M-x)
   ("C-x C-b" . helm-buffers-list)
   ("C-x C-r" . helm-mini)
   ("C-x b" . helm-mini)
   ("C-x R" . helm-register)
   ("C-h t" . helm-world-time)
   ("M-g a" . helm-do-grep-ag)
   ("M-g p" . helm-do-ag-project-root)
   ("M-g G" . helm-grep-do-git-grep))
  :init
  (defvar my/helm-display-help-buffer-regexp '("*.*Helm.*Help.**"))
  (defvar my/helm-display-buffer-regexp
    `("*.*helm.**"
      (display-buffer-in-side-window)
      (inhibit-same-window . t)
      (side . bottom)
      (window-width . 0.6)
      (window-height . 0.4)))

  (defun my/display-helm-window (buffer &optional resume)
    "Display the Helm window."
    (let ((display-buffer-alist
           (list my/helm-display-help-buffer-regexp
                 ;; this or any specialized case of Helm buffer must be
                 ;; added AFTER `my/helm-display-buffer-regexp'.
                 ;; Otherwise, `my/helm-display-buffer-regexp' will
                 ;; be used before
                 ;; `my/helm-display-help-buffer-regexp' and display
                 ;; configuration for normal Helm buffer is applied for helm
                 ;; help buffer, making the help buffer unable to be
                 ;; displayed.
                 my/helm-display-buffer-regexp)))
      (helm-default-display-buffer buffer)))

  (setq helm-grep-default-command
        "grep -a -d skip %e -n%cH -e %p %f"
        ;; may be overridden if 'ggrep' is in path (see below)
        helm-grep-default-recurse-command
        "grep -a -d recurse %e -n%cH -e %p %f"
        ;; use CURL, not url-retrieve-synchronously
        helm-net-prefer-curl t
        ;; be idle for this many seconds, before updating in delayed sources.
        helm-input-idle-delay 0
        ;; wider buffer name in helm-buffers-list
        helm-buffer-max-length 28 ;; default is 20
        ;; instead of "..." use a smaller unicode ellipsis
        helm-buffers-end-truncated-string "…"
        ;; open helm buffer in another window
        ;;helm-split-window-default-side 'other
        ;; set to nil and use <C-backspace> to toggle it in helm-find-files
        helm-ff-auto-update-initial-value nil
        ;; if I change the resplit state, re-use my settings
        helm-reuse-last-window-split-state t
        ;; don't delete windows to always have 2
        helm-always-two-windows nil
        ;; open helm buffer inside current window, don't occupy whole other window
        helm-split-window-inside-p t
        ;; display using my function, not helm's (helm is too slow here)
        helm-display-function #'my/display-helm-window
        ;; display helm in a separate frame
        ;; helm-display-function 'helm-display-buffer-in-own-frame
        ;; reuse frame so display is faster on Emacs 26+
        ;; helm-display-buffer-reuse-frame t
        ;; helm-display-buffer-width 144
        ;; helm-display-buffer-height 24
        ;; use undecorated frame on Emacs 26+
        helm-use-undecorated-frame-option t
        ;; don't check if the file exists on remote files
        helm-buffer-skip-remote-checking t
        ;; limit the number of displayed canidates
        helm-candidate-number-limit 100
        ;; don't use recentf stuff in helm-ff, I use C-x C-r for this
        helm-ff-file-name-history-use-recentf nil
        ;; move to end or beginning of source when reaching top or bottom
        ;; of source
        helm-move-to-line-cycle-in-source t
        ;; don't display the header line
        helm-display-header-line nil
        ;; verbosity for helm tramp messages
        helm-tramp-verbose 0
        ;; fuzzy matching
        helm-recentf-fuzzy-match t
        helm-locate-fuzzy-match nil ;; locate fuzzy is worthless
        helm-M-x-fuzzy-match t
        helm-buffers-fuzzy-matching t
        helm-semantic-fuzzy-match nil
        helm-gtags-fuzzy-match nil
        helm-imenu-fuzzy-match nil
        helm-apropos-fuzzy-match nil
        helm-lisp-fuzzy-completion nil
        helm-completion-in-region-fuzzy-match nil
        ;; autoresize to 25 rows
        helm-autoresize-min-height 25
        helm-autoresize-max-height 25
        ;; Here are the things helm-mini shows, I add `helm-source-bookmarks'
        ;; here to the regular default list
        helm-mini-default-sources '(helm-source-buffers-list
                                    helm-source-recentf
                                    helm-source-bookmarks
                                    helm-source-buffer-not-found)
        ;; Reduce the list of things for helm-apropos
        helm-apropos-function-list '(helm-def-source--emacs-commands
                                     helm-def-source--emacs-functions
                                     helm-def-source--emacs-variables
                                     helm-def-source--emacs-faces))
  :config
  (use-package helm-files
    :config (setq helm-ff-file-compressed-list '("gz" "bz2" "zip" "tgz" "xz" "txz")))
  (use-package helm-buffers
    :config
    (add-to-list 'helm-boring-buffer-regexp-list "^TAGS$")
    (add-to-list 'helm-boring-buffer-regexp-list "git-gutter:diff"))
  (use-package helm-mode
    :diminish helm-mode
    :init
    (add-hook 'after-init-hook #'helm-mode)
    (add-hook 'after-init-hook #'helm-autoresize-mode)
    (add-hook 'after-init-hook #'helm-adaptive-mode)
    (add-hook 'after-init-hook #'helm-popup-tip-mode))
  (use-package helm-sys
    :init (add-hook 'after-init-hook #'helm-top-poll-mode))
  (use-package helm-grep
    :config
    (setq helm-grep-truncate-lines nil)
    (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
    (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
    (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)
    (when (executable-find "rg")
      (setq helm-grep-ag-command "rg --color=always --colors 'match:fg:black' --colors 'match:bg:yellow' --smart-case --no-heading --line-number %s %s %s"
            helm-grep-ag-pipe-cmd-switches '("--colors 'match:fg:black'" "--colors 'match:bg:yellow'"))))
  (use-package helm-man)
  (use-package helm-misc)
  (use-package helm-elisp)
  (use-package helm-imenu)
  (use-package helm-semantic)
  (use-package helm-ring)
  (use-package smex :ensure t)
  (use-package helm-smex :ensure t)
  (use-package helm-bookmark
    :bind ("C-x M-b" . helm-bookmarks))
  (use-package projectile-ripgrep :ensure t)
  (use-package helm-projectile
    :ensure t
    :demand t ;; demand it be loaded!
    :bind (:map projectile-command-map
                ("b" . helm-projectile-switch-to-buffer)
                ("d" . helm-projectile-find-dir)
                ("f" . helm-projectile-find-file)
                ("p" . helm-projectile-switch-project)
                ("s s" . helm-projectile-ag)
                ("s r" . projectile-ripgrep))
    :init
    (setq projectile-switch-project-action 'helm-projectile)
    (helm-projectile-on)
    (helm-delete-action-from-source
     "Grep in projects `C-s'"
     helm-source-projectile-projects)
    (helm-add-action-to-source
     "Ag in project C-s'"
     'helm-do-ag helm-source-projectile-projects)
    (bind-key "C-s" (defun helm-projectile-do-ag ()
                      (interactive)
                      (helm-exit-and-execute-action #'helm-do-ag))
              helm-projectile-projects-map)
    (global-set-key (kbd "C-x f") #'helm-projectile-find-file)
    :config
    (setq-default helm-truncate-lines t
                  helm-projectile-truncate-lines t))

  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))

  ;; Use popwin for helm buffers, otherwise I can't get helm to display the way
  ;; I want (at the bottom, without deleting windows)
  ;; (when (fboundp 'popwin:special-display-config)
  ;;   (push '("^\*helm.+\*$" :regexp t :height 20) popwin:special-display-config)
  ;;   (setq helm-display-function 'popwin:pop-to-buffer))

  ;; Shows helm input in the header instead of the footer
  (setq helm-echo-input-in-header-line t)
  (defun helm-hide-minibuffer-maybe ()
    "Hide minibuffer in Helm session if we use the header line as input field."
    (when (with-helm-buffer helm-echo-input-in-header-line)
      (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
        (overlay-put ov 'window (selected-window))
        (overlay-put ov 'face
                     (let ((bg-color (face-background 'default nil)))
                       `(:background ,bg-color :foreground ,bg-color)))
        (setq-local cursor-type nil))))
  (add-hook 'helm-minibuffer-set-up-hook #'helm-hide-minibuffer-maybe)

  ;; Files that helm should know how to open
  (setq helm-external-programs-associations
        '(("avi"  . "mpv")
          ("part" . "mpv")
          ("mkv"  . "mpv")
          ("webm" . "mpv")
          ("mp4"  . "mpv")))

  ;; List of times to show in helm-world-time
  (setq display-time-world-list '(("PST8PDT" "Mountain View")
                                  ("America/Denver" "Denver")
                                  ("EST5EDT" "Boston")
                                  ("UTC" "UTC")
                                  ("Europe/London" "London")
                                  ("Europe/Amsterdam" "Amsterdam")
                                  ("Asia/Bangkok" "Bangkok")
                                  ("Asia/Tokyo" "Tokyo")
                                  ("Australia/Sydney" "Sydney")))

  ;; rebind tab to do persistent action
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  ;; make TAB works in terminal
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
  ;; list actions using C-z
  (define-key helm-map (kbd "C-z")  'helm-select-action)

  (define-key helm-map (kbd "C-p")   'helm-previous-line)
  (define-key helm-map (kbd "C-n")   'helm-next-line)
  (define-key helm-map (kbd "C-M-n") 'helm-next-source)
  (define-key helm-map (kbd "C-M-p") 'helm-previous-source)
  (define-key helm-map (kbd "M-N")   'helm-next-source)
  (define-key helm-map (kbd "M-P")   'helm-previous-source)

  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  ;; ggrep is gnu grep on OSX
  (when (executable-find "ggrep")
    (setq helm-grep-default-command
          "ggrep -a -d skip %e -n%cH -e %p %f"
          helm-grep-default-recurse-command
          "ggrep -a -d recurse %e -n%cH -e %p %f"))

  ;; helm-mini instead of recentf
  (define-key 'help-command (kbd "C-f") 'helm-apropos)
  (define-key 'help-command (kbd "r") 'helm-info-emacs)

  (defvar helm-httpstatus-source
    '((name . "HTTP STATUS")
      (candidates . (("100 Continue") ("101 Switching Protocols")
                     ("102 Processing") ("200 OK")
                     ("201 Created") ("202 Accepted")
                     ("203 Non-Authoritative Information") ("204 No Content")
                     ("205 Reset Content") ("206 Partial Content")
                     ("207 Multi-Status") ("208 Already Reported")
                     ("300 Multiple Choices") ("301 Moved Permanently")
                     ("302 Found") ("303 See Other")
                     ("304 Not Modified") ("305 Use Proxy")
                     ("307 Temporary Redirect") ("400 Bad Request")
                     ("401 Unauthorized") ("402 Payment Required")
                     ("403 Forbidden") ("404 Not Found")
                     ("405 Method Not Allowed") ("406 Not Acceptable")
                     ("407 Proxy Authentication Required") ("408 Request Timeout")
                     ("409 Conflict") ("410 Gone")
                     ("411 Length Required") ("412 Precondition Failed")
                     ("413 Request Entity Too Large")
                     ("414 Request-URI Too Large")
                     ("415 Unsupported Media Type")
                     ("416 Request Range Not Satisfiable")
                     ("417 Expectation Failed") ("418 I'm a teapot")
                     ("421 Misdirected Request")
                     ("422 Unprocessable Entity") ("423 Locked")
                     ("424 Failed Dependency") ("425 No code")
                     ("426 Upgrade Required") ("428 Precondition Required")
                     ("429 Too Many Requests")
                     ("431 Request Header Fields Too Large")
                     ("449 Retry with") ("500 Internal Server Error")
                     ("501 Not Implemented") ("502 Bad Gateway")
                     ("503 Service Unavailable") ("504 Gateway Timeout")
                     ("505 HTTP Version Not Supported")
                     ("506 Variant Also Negotiates")
                     ("507 Insufficient Storage") ("509 Bandwidth Limit Exceeded")
                     ("510 Not Extended")
                     ("511 Network Authentication Required")))
      (action . message)))

  (defvar helm-clj-http-source
    '((name . "clj-http options")
      (candidates
       .
       ((":accept - keyword for content type to accept")
        (":as - output coercion: :json, :json-string-keys, :clojure, :stream, :auto or string")
        (":basic-auth - string or vector of basic auth creds")
        (":body - body of request")
        (":body-encoding - encoding type for body string")
        (":client-params - apache http client params")
        (":coerce - when to coerce response body: :always, :unexceptional, :exceptional")
        (":conn-timeout - timeout for connection")
        (":connection-manager - connection pooling manager")
        (":content-type - content-type for request")
        (":cookie-store - CookieStore object to store/retrieve cookies")
        (":cookies - map of cookie name to cookie map")
        (":debug - boolean to print info to stdout")
        (":debug-body - boolean to print body debug info to stdout")
        (":decode-body-headers - automatically decode body headers")
        (":decompress-body - whether to decompress body automatically")
        (":digest-auth - vector of digest authentication")
        (":follow-redirects - boolean whether to follow HTTP redirects")
        (":form-params - map of form parameters to send")
        (":headers - map of headers")
        (":ignore-unknown-host? - whether to ignore inability to resolve host")
        (":insecure? - boolean whether to accept invalid SSL certs")
        (":json-opts - map of json options to be used for form params")
        (":keystore - file path to SSL keystore")
        (":keystore-pass - password for keystore")
        (":keystore-type - type of SSL keystore")
        (":length - manually specified length of body")
        (":max-redirects - maximum number of redirects to follow")
        (":mime-subtype - type for multipart mime parts")
        (":multipart - vector of multipart options")
        (":oauth-token - oauth token")
        (":proxy-host - hostname of proxy server")
        (":proxy-ignore-hosts - set of hosts to ignore for proxy")
        (":proxy-post - port for proxy server")
        (":query-params - map of query parameters")
        (":raw-headers - boolean whether to return raw headers with response")
        (":response-interceptor - function called for each redirect")
        (":retry-handler - function to handle HTTP retries on IOException")
        (":save-request? - boolean to return original request with response")
        (":socket-timeout - timeout for establishing socket")
        (":throw-entire-message? - whether to throw the entire response on errors")
        (":throw-exceptions - boolean whether to throw exceptions on 5xx & 4xx")
        (":trust-store - file path to trust store")
        (":trust-store-pass - password for trust store")
        (":trust-store-type - type of trust store")))
      (action . message)))

  (defun helm-httpstatus ()
    (interactive)
    (helm-other-buffer '(helm-httpstatus-source) "*helm httpstatus*"))

  (defun helm-clj-http ()
    (interactive)
    (helm-other-buffer '(helm-clj-http-source) "*helm clj-http flags*")))

(use-package helm-ls-git
  :ensure t
  :bind ("C-x C-d" . helm-browse-project))

(use-package helm-ls-hg
  :ensure t)

(use-package helm-ag
  :ensure t)

(use-package helm-swoop
  :ensure t
  :bind (("M-i" . helm-swoop)
         ("M-I" . helm-swoop-back-to-last-point)
         ("C-c M-i" . helm-multi-swoop))
  :config
  ;; When doing isearch, hand the word over to helm-swoop
  (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
  ;; From helm-swoop to helm-multi-swoop-all
  (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
  ;; Save buffer when helm-multi-swoop-edit complete
  (setq helm-multi-swoop-edit-save t
        ;; If this value is t, split window inside the current window
        helm-swoop-split-with-multiple-windows t
        ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
        helm-swoop-split-direction 'split-window-vertically
        ;; don't auto select the thing at point
        helm-swoop-pre-input-function (lambda () "")
        ;; If nil, you can slightly boost invoke speed in exchange for text
        ;; color. If I want pretty I'll use helm-occur since it keeps colors
        helm-swoop-speed-or-color nil))
(use-package helm-descbinds
  :ensure t
  :bind ("C-h b" . helm-descbinds)
  :init (fset 'describe-bindings 'helm-descbinds))

(use-package helm-flyspell
  :ensure t
  :after helm
  :bind (:map flyspell-mode-map
              ("C-;" . helm-flyspell-correct)))

(use-package projectile
  :ensure t
  :defer 5
  :commands projectile-global-mode
  :diminish projectile-mode
  :init (add-hook 'after-init-hook #'projectile-global-mode)
  :config
  (bind-key "C-c p b" #'projectile-switch-to-buffer #'projectile-command-map)
  (bind-key "C-c p K" #'projectile-kill-buffers #'projectile-command-map)

  ;; global ignores
  (add-to-list 'projectile-globally-ignored-files ".tern-port")
  (add-to-list 'projectile-globally-ignored-files "GTAGS")
  (add-to-list 'projectile-globally-ignored-files "GPATH")
  (add-to-list 'projectile-globally-ignored-files "GRTAGS")
  (add-to-list 'projectile-globally-ignored-files "GSYMS")
  (add-to-list 'projectile-globally-ignored-files ".DS_Store")
  ;; always ignore .class files
  (add-to-list 'projectile-globally-ignored-file-suffixes ".class")
  (use-package helm-projectile
    :ensure t
    :init
    (use-package grep) ;; required for helm-ag to work properly
    (setq projectile-completion-system 'helm)
    ;; no fuzziness for projectile-helm
    (setq helm-projectile-fuzzy-match nil)
    (helm-projectile-on)
    :config
    ;; Add multi-compile to the mix for projects
    (defun helm-projectile-multi-compile-project (dir)
      "A Helm action to invoke multi-compile on a project.
`dir' is the project root."
      (let ((default-directory dir))
        (multi-compile-run)))

    ;; Add new projectile binding for multi-compile
    (helm-projectile-define-key helm-projectile-projects-map
      (kbd "M-m")  #'helm-projectile-multi-compile-project)))

#+END_SRC
** Spacemacs theme
#+BEGIN_SRC emacs-lisp :tangle yes
(install-pkgs '(spacemacs-theme))
;(load-theme 'spacemacs-light)
#+END_SRC
** Groovy
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package groovy-mode
  :ensure t
  :config
  (setq groovy-indent-offset 2))
#+END_SRC
** Dired
Setup some awesome dired defaults
#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/dired-mode-hook ()
  (setq-local truncate-lines t))

(use-package dired
  :bind ("C-x C-j" . dired-jump)
  :config
  (use-package dired-x
    :init (setq-default dired-omit-files-p t)
    :config
    (add-to-list 'dired-omit-extensions ".DS_Store"))
  (customize-set-variable 'diredp-hide-details-initially-flag nil)
  (use-package dired-aux
        :init
        (use-package dired-async
          :ensure async))
      (put 'dired-find-alternate-file 'disabled nil)
      (setq ls-lisp-dirs-first t
            dired-recursive-copies 'always
            dired-recursive-deletes 'always
            dired-dwim-target t
            ;; -F marks links with @
            dired-ls-F-marks-symlinks t
            delete-by-moving-to-trash t
            ;; Don't auto refresh dired
            global-auto-revert-non-file-buffers nil
            wdired-allow-to-change-permissions t)
      (define-key dired-mode-map (kbd "C-M-u") #'dired-up-directory)
      (define-key dired-mode-map (kbd "M-o") #'my/dired-open)
      (define-key dired-mode-map (kbd "C-x C-q") #'wdired-change-to-wdired-mode)
      (bind-key "l" #'dired-up-directory dired-mode-map)
      (bind-key "M-!" #'async-shell-command dired-mode-map)
      (add-hook 'dired-mode-hook #'my/dired-mode-hook))
#+END_SRC

Quickly preview the things under the cursor
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package quick-preview
  :ensure t
  :init
  (global-set-key (kbd "C-c q") 'quick-preview-at-point)
  (define-key dired-mode-map (kbd "Q") 'quick-preview-at-point))
#+END_SRC

Pretty Icons in the dired buffers
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package all-the-icons
  :ensure t)
(use-package all-the-icons-dired
  :ensure t
  :diminish all-the-icons-dired-mode
  :init
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC

Filter dired results
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dired-narrow
  :ensure t
  :bind (:map dired-mode-map ("/" . dired-narrow)))
#+END_SRC
** Ediff
Setup your ediff for diffing efficiently

Open ediff window in the same frame
#+BEGIN_SRC emacs-lisp :tangle yes
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

Split window horizontally depending on window size
#+BEGIN_SRC emacs-lisp :tangle yes
(setq ediff-split-window-function (if (> (frame-width) 150)
                                      'split-window-horizontally
                                    'split-window-vertically))
#+END_SRC

Restore your windows after ediff session
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar my-ediff-bwin-config nil "Window configuration before ediff.")
(defcustom my-ediff-bwin-reg ?b
  "*Register to be set up to hold `my-ediff-bwin-config'
configuration.")

(defvar my-ediff-awin-config nil "Window configuration after ediff.")
(defcustom my-ediff-awin-reg ?e
      "*Register to be used to hold `my-ediff-awin-config' window
    configuration.")

    (defun my-ediff-bsh ()
      "Function to be called before any buffers or window setup for
    ediff."
      (setq my-ediff-bwin-config (current-window-configuration))
      (when (characterp my-ediff-bwin-reg)
    	(set-register my-ediff-bwin-reg
    		      (list my-ediff-bwin-config (point-marker)))))

    (defun my-ediff-ash ()
      "Function to be called after buffers and window setup for ediff."
      (setq my-ediff-awin-config (current-window-configuration))
      (when (characterp my-ediff-awin-reg)
    	(set-register my-ediff-awin-reg
    		      (list my-ediff-awin-config (point-marker)))))

    (defun my-ediff-qh ()
      "Function to be called when ediff quits."
      (when my-ediff-bwin-config
    	(set-window-configuration my-ediff-bwin-config)))

    (add-hook 'ediff-before-setup-hook 'my-ediff-bsh)
    (add-hook 'ediff-after-setup-windows-hook 'my-ediff-ash 'append)
    (add-hook 'ediff-quit-hook 'my-ediff-qh)
#+END_SRC
** Skeleton Code
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'skeleton)

(define-skeleton my/org-wrap-elisp
  "Wrap text with #+BEGIN_SRC / #+END_SRC for the emacs-lisp code"
  nil
  > "#+BEGIN_SRC emacs-lisp :tangle yes" \n
  > _ \n
  > "#+END_SRC" \n)

(define-skeleton my/org-wrap-source
  "Wrap text with #+BEGIN_SRC / #+END_SRC for a code type"
  "Language: "
  > "#+BEGIN_SRC " str ":tangle yes" \n
  > _ \n
  > "#+END_SRC" \n)

(define-skeleton my/java-try-catch
  "Wrap code in a Java try/catch"
  nil
  > "try {" \n
  > _
  > "} catch (Exception e) {" \n
  > "throw e;" \n
  > "}" \n)

(defhydra my/hydra-skeleton nil
  "Insert Skeleton"
  ("e" my/org-wrap-elisp "Wrap as elisp" :exit t)
  ("s" my/org-wrap-source "Wrap as source" :exit t)
  ("t" my/java-try-catch "Wrap with try/catch" :exit t))
#+END_SRC
** Eshell
Tweaking the eshell to give'em ehell
#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/setup-eshell ()
  (interactive)
  ;; turn off semantic-mode in eshell buffers Needed?
  (semantic-mode -1)

  (local-set-key (kbd "M-P") 'eshell-previous-prompt)
  (local-set-key (kbd "M-N") 'eshell-next-prompt)
  (local-set-key (kbd "M-R") 'eshell-previous-matching-input))
#+END_SRC

A nice helper to sudo-edit a file
#+BEGIN_SRC emacs-lisp :tangle yes
(defun sudoec (file)
  (interactive)
  (find-file (concat "/sudo::" (expand-file-name file))))
#+END_SRC

Setup some nice settings for eshell
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package eshell
  :commands (eshell eshell-command)
  :bind ("C-c m" . eshell)
  :init
  (require 'em-smart)
  (setq eshell-glob-case-insensitive nil
        eshell-error-if-no-glob nil
        eshell-scroll-to-bottom-on-input nil
        eshell-where-to-jump 'begin
        eshell-review-quick-commands nil
        eshell-smart-space-goes-to-end t)
  ;; Initialize "smart" mode
  ;;(add-hook 'eshell-mode-hook #'eshell-smart-initialize)
  :config
  (defalias 'emacs 'find-file)
  (defalias 'hff 'hexl-find-file)
  (defalias 'sec 'sudoec)
  (setenv "PAGER" "cat")
  (use-package esh-opt
    :config
    (use-package em-cmpl)
    (use-package em-prompt
      :init
      (with-eval-after-load 'em-prompt
        (defun eshell-next-prompt (n)
          "Move to end of Nth next prompt in the buffer. See `eshell-prompt-regexp'."
          (interactive "p")
          (re-search-forward eshell-prompt-regexp nil t n)
          (when eshell-highlight-prompt
          (while (not (get-text-property (line-beginning-position) 'read-only))
            (re-search-forward eshell-prompt-regexp nil t n)))
          (eshell-skip-prompt))

        (defun eshell-previous-prompt (n)
          "Move to end of Nth previous prompt in the buffer. See `eshell-prompt-regexp'."
          (interactive "p")
          (backward-char)
          (eshell-next-prompt (- n)))))
    (use-package em-term)

    ;; Shared history.
    (defvar eshell-history-global-ring nil
      "The history ring shared across Eshell sessions.")

    ;; (defun eshell-hist-use-global-history ()
    ;;   "Make Eshell history shared across different sessions."
    ;;   (unless eshell-history-global-ring
    ;;     (let (eshell-history-ring)
    ;;       (when eshell-history-file-name
    ;;         (eshell-read-history nil t))
    ;;       (setq eshell-history-global-ring eshell-history-ring))
    ;;     (unless eshell-history-ring (setq eshell-history-global-ring (make-ring eshell-history-size))))
    ;;   (setq eshell-history-ring eshell-history-global-ring))
    ;; (add-hook 'eshell-mode-hook 'eshell-hist-use-global-history)

    (setq eshell-cmpl-cycle-completions nil
          ;; auto truncate after 12k lines
          eshell-buffer-maximum-lines 12000
          ;; history size
          eshell-history-size 500
          ;; buffer shorthand -> echo foo > #'buffer
          eshell-buffer-shorthand t
          ;; my prompt is easy enough to see
          eshell-highlight-prompt nil
          ;; treat 'echo' like shell echo
          eshell-plain-echo-behavior t
          ;; add -lh to the `ls' flags
          eshell-ls-initial-args "-lh")

    ;; Visual commands
    (setq eshell-visual-commands '("vi" "screen" "top" "less" "more" "lynx"
                                   "ncftp" "pine" "tin" "trn" "elm" "vim"
                                   "nmtui" "alsamixer" "htop" "el" "elinks"
                                   "ssh" "nethack" "dtop" "dstat"))
    (setq eshell-visual-subcommands '(("git" "log" "diff" "show")
                                      ("vagrant" "ssh")))

    (defun my/truncate-eshell-buffers ()
      "Truncates all eshell buffers"
      (interactive)
      (save-current-buffer
        (dolist (buffer (buffer-list t))
          (set-buffer buffer)
          (when (eq major-mode 'eshell-mode)
            (eshell-truncate-buffer)))))

    ;; After being idle for 5 seconds, truncate all the eshell-buffers if
    ;; needed. If this needs to be canceled, you can run `(cancel-timer
    ;; my/eshell-truncate-timer)'
    (setq my/eshell-truncate-timer
          (run-with-idle-timer 5 t #'my/truncate-eshell-buffers))

    (defun eshell/cds ()
      "Change directory to the project's root."
      (eshell/cd (locate-dominating-file default-directory ".git")))

    (defalias 'eshell/l 'eshell/ls)
    (defalias 'eshell/ll 'eshell/ls)

    (defun eshell/ec (pattern)
      (if (stringp pattern)
          (find-file pattern)
        (mapc #'find-file (mapcar #'expand-file-name pattern))))
    (defalias 'e 'eshell/ec)
    (defalias 'ee 'find-file-other-window)

    (defun eshell/d (&rest args)
      (dired (pop args) "."))

    (defun eshell/clear ()
      "Clear the eshell buffer"
      (interactive)
      (let ((eshell-buffer-maximum-lines 0))
        (eshell-truncate-buffer)
        (let ((inhibit-read-only t))
          (erase-buffer)
          (eshell-send-input)))))

  (defun eshell/icat (&rest args)
    "Display image(s)."
    (let ((elems (eshell-flatten-list args)))
      (while elems
        (eshell-printn
         (propertize " "
                     'display (create-image (expand-file-name (car elems)))))
        (setq elems (cdr elems))))
    nil)

  (add-hook 'eshell-mode-hook #'my/setup-eshell)

  ;; See eshell-prompt-function below
  (setq eshell-prompt-regexp "^[^#$\n]* [#$] ")

  ;; So the history vars are defined
  (require 'em-hist)
  (if (boundp 'eshell-save-history-on-exit)
      ;; Don't ask, just save
      (setq eshell-save-history-on-exit t))

  ;; See: https://github.com/kaihaosw/eshell-prompt-extras
  (use-package eshell-prompt-extras
    :ensure t
    :init
    (progn
      (setq eshell-highlight-prompt nil
            epe-git-dirty-char " Ϟ"
            ;; epe-git-dirty-char "*"
            eshell-prompt-function 'epe-theme-dakrone)))

  (defun eshell/magit ()
    "Function to open magit-status for the current directory"
    (interactive)
    (magit-status default-directory)
    nil))

  (use-package esh-autosuggest
    :ensure t
    :hook (eshell-mode . esh-autosuggest-mode))
#+END_SRC

Create eshell buffers with the press of a button
#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/create-or-switch-to-delta-buffer ()
  "Switch to the *eshell delta* buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell-delta*")
      (switch-to-buffer "*eshell-delta*")
    (let ((eshell-buffer-name "*eshell-delta*"))
      (eshell))))

(global-set-key (kbd "C-x d") 'my/create-or-switch-to-delta-buffer)

(defun my/create-or-switch-to-eshell-1 ()
  "Switch to the *eshell* buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell*")
      (switch-to-buffer "*eshell*")
    (let ((eshell-buffer-name "*eshell*"))
      (eshell))))

(defun my/create-or-switch-to-eshell-2 ()
  "Switch to the *eshell*<2> buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell*<2>")
      (switch-to-buffer "*eshell*<2>")
    (let ((eshell-buffer-name "*eshell*<2>"))
      (eshell))))

(defun my/create-or-switch-to-eshell-3 ()
  "Switch to the *eshell*<3> buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell*<3>")
      (switch-to-buffer "*eshell*<3>")
    (let ((eshell-buffer-name "*eshell*<3>"))
      (eshell))))

(defun my/create-or-switch-to-eshell-4 ()
  "Switch to the *eshell*<4> buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell*<4>")
      (switch-to-buffer "*eshell*<4>")
    (let ((eshell-buffer-name "*eshell*<4>"))
      (eshell))))

(defun my/create-all-eshell-buffers ()
  "Create all my normal eshell buffers"
  (interactive)
  (let ((eshell-buffer-name "*eshell*")
        (default-directory "~/"))
    (eshell))
  (let ((eshell-buffer-name "*eshell*<2>")
        (default-directory "~/")) (eshell))
  (let ((eshell-buffer-name "*eshell*<3>")
        (default-directory "~/gitrepo"))
    (eshell))
  (let ((eshell-buffer-name "*eshell-delta*")
        (default-directory "~/.emacs.d"))
    (eshell))
  (let ((eshell-buffer-name "*eshell downloads*")
        (default-directory "~/Downloads"))
    (eshell)))

(global-set-key (kbd "M-@") #'my/create-all-eshell-buffers)

(global-set-key (kbd "H-1") 'my/create-or-switch-to-eshell-1)
(global-set-key (kbd "H-2") 'my/create-or-switch-to-eshell-2)
(global-set-key (kbd "H-3") 'my/create-or-switch-to-eshell-3)
(global-set-key (kbd "H-4") 'my/create-or-switch-to-eshell-4)
(global-set-key (kbd "s-1") 'my/create-or-switch-to-eshell-1)
(global-set-key (kbd "s-2") 'my/create-or-switch-to-eshell-2)
(global-set-key (kbd "s-3") 'my/create-or-switch-to-eshell-3)
(global-set-key (kbd "s-4") 'my/create-or-switch-to-eshell-4)
(global-set-key (kbd "M-1") 'my/create-or-switch-to-eshell-1)
(global-set-key (kbd "M-2") 'my/create-or-switch-to-eshell-2)
(global-set-key (kbd "M-3") 'my/create-or-switch-to-eshell-3)
(global-set-key (kbd "M-4") 'my/create-or-switch-to-eshell-4)
#+END_SRC

Open an eshell window in the current directory of the open buffer
#+BEGIN_SRC emacs-lisp :tangle yes
(defun eshell-here ()
  "Opens up a new shell in the directory associated with the
current buffer's file. The eshell is renamed to match that
directory to make multiple eshell windows easier."
  (interactive)
  (let* ((parent (if (buffer-file-name)
                     (file-name-directory (buffer-file-name))
                   default-directory))
         (height (/ (window-total-height) 3))
         (name   (car (last (split-string parent "/" t)))))
    (split-window-vertically (- height))
    (other-window 1)
    (eshell "new")
    (rename-buffer (concat "*eshell: " name "*"))

    (insert (concat "ls"))
    (eshell-send-input)))

(global-set-key (kbd "C-!") #'eshell-here)
#+END_SRC

Quickly close eshell window
#+BEGIN_SRC emacs-lisp :tangle yes
(defun eshell/x ()
  "Closes the EShell session and gets rid of the EShell window."
   (delete-window)
   (eshell/exit))
#+END_SRC
** Sunrise Commander
File management at it's best
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'load-path "~/.emacs.d/site-lisp/sunrise-commander/")
(require 'sunrise-commander)
#+END_SRC
** Editorconfig
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :ensure t)
#+END_SRC
** Server
#+BEGIN_SRC emacs-lisp :tangle yes
;; start emacs server only if it has not started already
(require 'server)
(unless (server-running-p) (server-start))
#+END_SRC
** Hooks
Run some things when everything is loaded.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'after-emacs-hook
          (lambda ()
            (message "Emacs has loaded")))

(defun my/time-since-start ()
  (float-time (time-subtract (current-time)
                             emacs-start-time)))

(add-hook 'after-emacs-hook
          `(lambda ()
             (let ((elapsed (my/time-since-start)))
               (message "Loading %s...done (%.3fs)"
                        ,load-file-name elapsed))) t)
(add-hook 'after-init-hook
          `(lambda ()
             (let ((elapsed (my/time-since-start)))
               (message "Loading %s...done (%.3fs) [after-init]"
                        ,load-file-name elapsed))) t)
(run-hooks 'after-emacs-hook)
#+END_SRC
