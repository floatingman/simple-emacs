* Emacs Config
** Let's get bootstrapped
*** Turn on debug
#+BEGIN_SRC emacs-lisp :tangle yes
(setq debug-on-error t)
(setq debug-on-quit t)
#+END_SRC
*** Setup package repositories
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'cl)
(require 'package)

(setq package-enable-at-startup nil)

;; orgmode.org unfortunately does not support https
(add-to-list 'package-archives
             '("org" . "http://orgmode.org/elpa/") t)
(add-to-list 'package-archives
             '("gnu" . "https://elpa.gnu.org/packages/") t)
(add-to-list 'package-archives
             '("melpa-stable" . "https://stable.melpa.org/packages/") t)
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/") t)

(unless package--initialized (package-initialize t))

(when (< emacs-major-version 27)
  (package-initialize))

;; Install use-package
(if (package-installed-p 'use-package)
    (require 'use-package)
    (progn
      (package-refresh-contents)
      (package-install 'use-package)))


(defvar my/did-refresh-packages nil
  "Flag for wheater packages have been refreshed yet")

;; Utility to install a list of packages
(defun install-pkgs (list)
  (dolist (pkg list)
    (progn
      (if (not (package-installed-p pkg))
          (progn
            (if (not my/did-refresh-packages)
                (progn (package-refresh-contents)
                       (setq my/did-refresh-packages t)))
            (package-install pkg))))))

;;Pin some of the packages that go wonky if I use the bleeding edge.

(when (boundp 'package-pinned-packages)
  (setq package-pinned-packages
        '((org-plus-contrib                  . "org")
          (cider                             . "melpa-stable")
          (ac-cider                          . "melpa-stable")
          (clojure-mode                      . "melpa-stable")
          (clojure-mode-extra-font-locking   . "melpa-stable")
          (company-cider                     . "melpa-stable"))))

;; Load use-package, used for loading packages everywhere else
(require 'use-package nil t)
;; Set to t to debug package loading or nil to disable
(setq use-package-verbose nil)
#+END_SRC
*** Display loading information
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar after-emacs-hook nil
  "Hooks to run after all of the Emacs has been loaded")

(defvar emacs-start-time (current-time)
  "Time Emacs was started.")
#+END_SRC
*** Add site-lisp directory
For custom scripts
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'load-path "~/.emacs.d/site-lisp/")
#+END_SRC
** Load them environment variables
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :ensure t
  :if (memq window-system '(mac nx x))
  :init (exec-path-from-shell-initialize))
#+END_SRC

** Internal configuration
Just copying this verbose now
#+BEGIN_SRC emacs-lisp :tangle yes
(defun find-config ()
  "Edit config.org"
  (interactive)
  (find-file "~/.emacs.d/config.org"))
(global-set-key (kbd "C-c I") 'find-config)

(use-package f
  :ensure t)
(use-package general
  :ensure t)
(setq-default
   ;;;   Use spaces and not tabs for indentation
 indent-tabs-mode nil

   ;;;   Don't highlight trailing whitespaces by default
 show-trailing-whitespace nil

   ;;;   Org
 org-src-fontify-natively t ;; Fontify source blocks
 org-src-tab-acts-natively t ;; indention in src blocks should work
 )
   ;;;   Customizations go to this file
(setq custom-file "~/personal/custom.el")
(when (file-exists-p custom-file)
  (load custom-file))

(setq
   ;;;   Node.js path from nvm
 exec-path (append exec-path '("~/.nvm/versions/node/v8.11.2/bin"))

   ;;;   User details
 user-mail-address "dwnewman78@gmail.com"
 user-full-name    "Daniel Newman"

   ;;;   Follow symlinks to the actual file
 find-file-visit-truename t
 vc-follow-symlinks t

   ;;;   Jump by words separated by punctuations
 global-subword-mode t

   ;;;   Turn on every disabled function
 disabled-command-function nil

   ;;;   Use UTF-8 characters in buffer
 buffer-file-coding-system 'utf-8

   ;;;   Clipboard length
 kill-ring-max 1024

   ;;;   Sentences are separated by single space after dot(.)
 sentence-end-double-space nil

   ;;;   Don't compact font cache during GC to optimize redisplay
 inhibit-compacting-font-caches t

   ;;;   GC triggers per 7 MB increase in memory
 gc-cons-threshold 58720256

   ;;;   No bells
 ring-bell-function 'ignore
 visible-bell nil

   ;;;   Themes are safe after all
 custom-safe-themes t

   ;;;   No startup show off
 inhibit-startup-screen t

   ;;;   Show line number for any normal width line
 line-number-display-limit-width 10000000

   ;;;   Some TLS connections might have larger PRIME bits
 gnutls-min-prime-bits 4096

   ;;;   Better unique names of similar filenames and buffer-names
 uniquify-buffer-name-style 'forward

   ;;;   We can use TCP connection to connect to remote Emacs instance
 server-use-tcp t

   ;;;   Save existing interprogram clipboard text before replacing it
 save-interprogram-paste-before-kill t

   ;;;   Set REPL programs' prompt as read only
 comint-prompt-read-only t

   ;;;   Use commands when in in minibuffer
 enable-recursive-minibuffers t

   ;;;   Scroll output in *compilation* buffer
 compilation-scroll-output t

   ;;;   Scroll one line at a time no matter what
 scroll-step            1
 scroll-conservatively  10000
 mouse-wheel-scroll-amount '(1 ((shift) . 1))

   ;;;   Remember screen position after scrolling
 scroll-preserve-screen-position 'always

   ;;;   Initial scratch message is nil
 initial-scratch-message ""

   ;;;   Use directory local variables in tramp session
 enable-remote-dir-locals t

   ;;;   Backup configuration
 tramp-persistency-file-name "~/.emacs.d/.cache/tramp"
 backup-directory-alist '(("." . "~/.emacs.d/.cache/backups"))
 delete-old-versions -1
 version-control t
 vc-make-backup-files t
 auto-save-file-name-transforms '((".*" "~/.emacs.d/.cache/auto-save-list" t))
 auto-save-list-file-prefix "~/.emacs.d/.cache/auto-save-list/saves-"


   ;;;   Ediff
 ediff-window-setup-function 'ediff-setup-windows-plain ;; Single frame ediff session

   ;;;   Ido mode
 ido-enable-flex-matching t
 ido-save-directory-list-file "~/.emacs.d/.cache/ido.last"

   ;;;   Line numbers
 display-line-numbers-type 'visual
 )

(with-eval-after-load 'ox-latex
    ;;;   Set colors when exporting to latex
  (setq org-latex-listings t))

(f-mkdir "~/.emacs.d/.cache" "auto-save-list")
(f-mkdir tramp-persistency-file-name)

(fset 'yes-or-no-p 'y-or-n-p)

(blink-cursor-mode 0)

(when (file-readable-p custom-file)
  (load custom-file))

(when (file-readable-p "~/.git-tokens")
  (load-file "~/.git-tokens"))

(set-language-environment 'utf-8)
(set-default-coding-systems 'utf-8)
(set-selection-coding-system 'utf-8)
(set-locale-environment "en.UTF-8")
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

(set-frame-font "Iosevka")

(menu-bar-mode 0)
(tool-bar-mode 0)
(menu-bar-no-scroll-bar)

(column-number-mode 1)
(display-time-mode 1)

(delete-selection-mode 1)

  ;;;   Automatically change to newest version of file if edited externally
(global-auto-revert-mode t)

  ;;;   Highlight matching pairs like (), {}, [], etc.
(show-paren-mode t)

  ;;;   Enable line numbers in fundamental mode
(add-hook 'text-mode-hook 'display-line-numbers-mode)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)

(defun my/set-show-whitespace-mode ()
  "Show white space in current buffer"
  (setq show-trailing-whitespace t))
;; Show whitespaces only in buffers pointing to specific files
(add-hook 'find-file-hook 'my/set-show-whitespace-mode)
;; Remove the trailing whitespaces on save
(add-hook 'before-save-hook 'delete-trailing-whitespace)

(with-eval-after-load 'abbrev
  (progn
    (when (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file))
    (when (file-exists-p "./my-abbrev.el")
      (load "./my-abbrev.el"))))

  ;;;   Highlighting current line is improtant when lines are long in tables

(when (fboundp 'xwidget-webkit-browse-url)
  (use-package xwidget
    :ensure t
    :general
    (:keymaps 'xwidget-webkit-mode-map
              "<mouse-4>" 'xwidget-webkit-scroll-down
              "<mouse-5>" 'xwidget-webkit-scroll-up
              "<up>" 'xwidget-webkit-scroll-down
              "<down>" 'xwidget-webkit-scroll-up
              "M-w" 'xwidget-webkit-copy-selection-as-kill
              "C-c" 'xwidget-webkit-copy-selection-as-kill)
    :hook
    (window-configuration-change-hook
     . (lambda ()
         (when (equal major-mode 'xwidget-webkit-mode)
           (xwidget-webkit-adjust-size-dispatch))))
    :init
    ;; by default, xwidget reuses previous xwidget window,
    ;; thus overriding your current website, unless a prefix argument
    ;; is supplied
    ;; This function always opens a new website in a new window
    (defun xwidget-browse-url-no-reuse (url &optional session)
      (interactive
       (progn
         (require 'browse-url)
         (browse-url-interactive-arg "xwidget-webkit URL: ")))
      (xwidget-webkit-browse-url url t)))
  )


(defcustom minibuffer-message-list
  '("Let the hacking begin!"
    "Welcome to Emacs!"
    "Have a good day!"
    "Good luck configuring Emacs!"
    "Better concentrate on your work"
    "Don’t even think about other editors"
    "Are you sleeping?"
    "Sorry, if I broke your concentration!"
    "Please update me"
    "The minibuffer sucks!"
    "Remember the day when we first met?"
    "Did you stop typing?"
    "You should commit your changes before you mess up"
    "I am on a loop"
    "You should keep a log of your tasks"
    "Please don’t quit! Please!"
    "Did you call your Mom?"
    "I am older than you"
    "Don’t get into the XY problem"
    "Get some rest")
  "List of messages that are displayed in the minibuffer after a specific period
  of time controlled by `minibuffer-message-display-interval'."
  :type '(repeat string))


(defvar minibuffer-message-display-interval 5
  "Time in minutes after which a random message from `minibuffer-message-list'
  is shown in minibuffer.")


(defvar minibuffer-message-echo-timer nil
  "Object that stores the timer for messages that are displayed in the
  minibuffer using `display-startup-echo-area-message'.")


(defun restart-minibuffer-message-display-timer (func)
  "Start the minibuffer timer with `FUNC' running per
  `minibuffer-message-display-interval'."
  (when minibuffer-message-echo-timer (cancel-timer minibuffer-message-echo-timer))
  (setq minibuffer-message-echo-timer
        (run-with-timer 0 (* minibuffer-message-display-interval 60) func)))


(defun display-startup-echo-area-message ()
  "Show a message in minibuffer."
  (interactive)
  (message
   (let* ((length (length minibuffer-message-list))
          (random-number (abs (% (random) length))))
     (car (nthcdr random-number minibuffer-message-list)))))


(restart-minibuffer-message-display-timer 'display-startup-echo-area-message)


(defun toggle-minibuffer-message-timer ()
  "Toggle minibuffer message showing per
  `minibuffer-message-display-interval'."
  (interactive)
  (if (null minibuffer-message-echo-timer)
      (restart-minibuffer-message-display-timer 'display-startup-echo-area-message)
    (cancel-timer minibuffer-message-echo-timer)
    (setq minibuffer-message-echo-timer)))


(setq recentf-max-saved-items 512
      history-length t
      history-delete-duplicates t
      recentf-save-file "~/.emacs.d/.cache/recentf"
      savehist-file "~/.emacs.d/.cache/savehist"
      save-place-file "~/.emacs.d/.cache/saveplace"
      savehist-additional-variables '(kill-ring
                                      extended-command-history
                                      global-mark-ring
                                      mark-ring
                                      regexp-search-ring
                                      search-ring))
(save-place-mode 1)
(savehist-mode 1)
(recentf-mode 1)

(defun my-comint-preoutput-read-only (text)
  (propertize text 'read-only t))

(add-hook 'comint-preoutput-filter-functions
          'my-comint-preoutput-read-only)

(defun my-comint-last-output-beg ()
  (save-excursion
    (comint-goto-process-mark)
    (while (not (or (eq (get-char-property (point) 'field) 'boundary)
                    (= (point) (point-min))))
      (goto-char (previous-char-property-change (point) (point-min))))
    (if (= (point) (point-min))
        (point)
      (1+ (point)))))

(defun my-comint-last-output-end ()
  (save-excursion
    (comint-goto-process-mark)
    (while (not (or (eq (get-char-property (point) 'font-lock-face)
                        'comint-highlight-prompt)
                    (= (point) (point-min))))
      (goto-char (previous-char-property-change (point) (point-min))))
    (let ((overlay (car (overlays-at (point)))))
      (when (and overlay (eq (overlay-get overlay 'font-lock-face)
                             'comint-highlight-prompt))
        (goto-char (overlay-start overlay))))
    (1- (point))))

(defun my-comint-clear-last-output ()
  (interactive)
  (let ((start (my-comint-last-output-beg))
        (end (my-comint-last-output-end)))
    (let ((inhibit-read-only t))
      (delete-region start end)
      (save-excursion
        (goto-char start)
        (insert (propertize "output cleared"
                            'font-lock-face 'font-lock-comment-face))))))

(defun my-shell-kill-buffer-sentinel (process event)
  (when (and (memq (process-status process) '(exit signal))
             (buffer-live-p (process-buffer process)))
    (kill-buffer)))

(defun my-kill-process-buffer-on-exit ()
  (set-process-sentinel (get-buffer-process (current-buffer))
                        #'my-shell-kill-buffer-sentinel))

(dolist (hook '(ielm-mode-hook term-exec-hook comint-exec-hook))
  (add-hook hook 'my-kill-process-buffer-on-exit))

(defun my-kill-word (arg)
  (interactive "p")
  (unless buffer-read-only
    (let ((beg (point))
          (end (save-excursion (forward-word arg) (point)))
          (point (save-excursion (goto-char
                                  (if (> arg 0)
                                      (next-single-char-property-change
                                       (point) 'read-only)
                                    (previous-single-char-property-change
                                     (point) 'read-only)))
                                 (point))))
      (unless (get-char-property (point) 'read-only)
        (if (if (> arg 0) (< point end) (> point end))
            (kill-region beg point)
          (kill-region beg end))))))

(defun my-backward-kill-word (arg)
  (interactive "p")
  (my-kill-word (- arg)))

(with-eval-after-load 'comint
  (general-define-key
   :kemaps 'comint-mode-map
   "<remap> <kill-word>" 'my-kill-word
   "<remap> <backward-kill-word>" 'my-backward-kill-word
   "C-S-l" 'my-comint-clear-last-output))

(defun my-shell-turn-echo-off ()
  (setq comint-process-echoes t))

(add-hook 'shell-mode-hook 'my-shell-turn-echo-off)

(setq hippie-expand-try-functions-list
      '(yas-hippie-try-expand
        try-expand-all-abbrevs
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-dabbrev
        try-expand-dabbrev-from-kill
        try-expand-dabbrev-all-buffers
        try-expand-list
        try-expand-line
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))

(minibuffer-depth-indicate-mode 1)

(use-package winner
  :ensure t
  :init
  (winner-mode 1))

(global-prettify-symbols-mode 1)
(add-hook 'python-mode-hook 'python-prettify-symbols)
(defun python-prettify-symbols ()
  (mapc (lambda (pair) (push pair prettify-symbols-alist))
        '(;; Syntax
          ("def" .      #x2131)
          ("not" .      #x2757)
          ("in" .       #x2208)
          ("not in" .   #x2209)
          ("return" .   #x27fc)
          ("yield" .    #x27fb)
          ("for" .      #x2200)
          ;; conditions
          ("!=" .       #x2260)
          ("<=" .       #x2264)
          (">=" .       #x2265)
          ;; Base Types
          ("int" .      #x2124)
          ("float" .    #x211d)
          ("str" .      #x1d54a)
          ("True" .     #x1d54b)
          ("False" .    #x1d53d)
          )))

(defun mplist-remove (plist prop)
  "Return a copy of a modified PLIST without PROP and its values.

  If there are multiple properties with the same keyword, only the first property
  and its values are removed."
  (let ((tail plist)
        result)
    (while (and (consp tail) (not (eq prop (car tail))))
      (push (pop tail) result))
    (when (eq prop (car tail))
      (pop tail)
      (while (and (consp tail) (not (keywordp (car tail))))
        (pop tail)))
    (while (consp tail)
      (push (pop tail) result))
    (nreverse result)))

(defun set-default-font (plists)
  "Set the font given the passed PLISTS.

  PLISTS has either the form (\"fontname\" :prop1 val1 :prop2 val2 ...)
  or is a list of such. The first font that can be found will be used.

  The return value is nil if no font was found, truthy otherwise."
  (unless (listp (car plists))
    (setq plists (list plists)))
  (catch 'break
    (dolist (plist plists)
      (when (find-font (font-spec :name (car plist)))
        (let* ((font (car plist))
               (props (cdr plist))
               (font-props (mplist-remove
                            ;; although this keyword does not exist anymore
                            ;; we keep it for backward compatibility
                            (mplist-remove props :powerline-scale)
                            :powerline-offset))
               (fontspec (apply 'font-spec :name font font-props)))
          (set-frame-font fontspec nil t)
          (push `(font . ,(frame-parameter nil 'font)) default-frame-alist)
          (pcase system-type
            (`gnu/linux
             (setq fallback-font-name "Iosevka")
             (setq fallback-font-name2 "Iosevka"))
            (`darwin
             (setq fallback-font-name "Iosevka")
             (setq fallback-font-name2 "Iosevka"))
            (`windows-nt
             (setq fallback-font-name "Iosevka")
             (setq fallback-font-name2 "Iosevka"))
            (`cygwin
             (setq fallback-font-name "Iosevka")
             (setq fallback-font-name2 "Iosevka"))
            (other
             (setq fallback-font-name nil)
             (setq fallback-font-name2 nil)))
          (when (and fallback-font-name fallback-font-name2)
            ;; remove any size or height properties in order to be able to
            ;; scale the fallback fonts with the default one (for zoom-in/out
            ;; for instance)
            (let* ((fallback-props (mplist-remove
                                    (mplist-remove font-props :size)
                                    :height))
                   (fallback-spec (apply 'font-spec
                                         :name fallback-font-name
                                         fallback-props))
                   (fallback-spec2 (apply 'font-spec
                                          :name fallback-font-name2
                                          fallback-props)))
              ;; window numbers
              (set-fontset-font "fontset-default"
                                '(#x2776 . #x2793) fallback-spec nil 'prepend)
              ;; mode-line circled letters
              (set-fontset-font "fontset-default"
                                '(#x24b6 . #x24fe) fallback-spec nil 'prepend)
              ;; mode-line additional characters
              (set-fontset-font "fontset-default"
                                '(#x2295 . #x22a1) fallback-spec nil 'prepend)
              ;; new version lighter
              (set-fontset-font "fontset-default"
                                '(#x2190 . #x2200) fallback-spec2 nil 'prepend))))
        (throw 'break t)))
    nil))

(set-default-font '("Iosevka"
                    :size 16
                    :weight normal
                    :width normal))

(require 'ansi-color)
(defun colorize-compilation-buffer ()
  "Colorize the compilation buffer with ANSI escape sequences."
  (toggle-read-only)
  (ansi-color-apply-on-region (point-min) (point-max))
  (toggle-read-only))
(add-hook 'compilation-filter-hook 'colorize-compilation-buffer)

(defun my-org-autodone (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-log-states)   ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
(add-hook 'org-after-todo-statistics-hook 'my-org-autodone)


  ;;;   Fontify exported PDF using minted
;; Include the latex-exporter
(require 'ox-latex)
;; Add minted to the defaults packages to include when exporting.
(add-to-list 'org-latex-packages-alist '("" "minted"))
;; Tell the latex export to use the minted package for source
;; code coloration.
(setq org-latex-listings 'minted)
;; Let the exporter use the -shell-escape option to let latex
;; execute external programs.
;; This obviously and can be dangerous to activate!

;; I use pdflatex instead of xelatex because that seems to work
;; much better with utf-8 files
(setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
  ;;;   end


;; No box around modeline
(defun after-init-jobs ()
  "Configurations run after Emacs starts."
  (set-face-attribute 'mode-line nil :box nil)
  (set-face-attribute 'mode-line-inactive nil :box nil)
  (remove-hook 'after-init-hook 'after-init-jobs))

(add-hook 'after-init-hook 'after-init-jobs)

#+END_SRC

** Function toget basename of a given path
#+BEGIN_SRC emacs-lisp :tangle yes
(defun basename (path)
  "Returns just the file name of the given PATH."
  (file-name-nondirectory (directory-file-name path)))
#+END_SRC

** OS Specific
Setup some variables for use in other config files
#+BEGIN_SRC emacs-lisp :tangle yes
(defconst *spell-check-support-enabled* t) ;; Enable with t if you prefer
(defconst *is-a-mac* (eq system-type 'darwin))
(defconst *is-windows* (eq system-type 'windows-nt))
(defconst *is-linux* (eq system-type 'gnu/linux))
(defconst *is-gui* (not (eq window-system nil)))
(defvar running-alternate-emacs nil)
#+END_SRC
Linux
,#+BEGIN_SRC emacs-lisp :tangle yes
(when *is-linux*
  ;; Whether to use GTK tooltips or emacs ones
  (setq x-gtk-use-system-tooltips t)
  (setq dired-listing-switches "-lFaGh1v --group-directories-first"))
#+END_SRC

Mac OSX
#+BEGIN_SRC emacs-lisp :tangle yes
(when *is-a-mac*
  (if (executable-find "gls")
      (progn
        (setq insert-directory-program "gls")
        (setq dired-listing-switches "-lFaGh1v --group-directories-first"))
    (setq dired-listing-switches "-ahlF"))
  (defun copy-from-osx ()
    "Handle copy/paste intelligently on osx."
    (let ((pbpaste (purecopy "/usr/bin/pbpaste")))
      (if (and *is-a-mac*
               (file-exists-p pbpaste))
          (let ((tramp-mode nil)
                (default-directory "~"))
            (shell-command-to-string pbpaste)))))

  (defun paste-to-osx (text &optional push)
    (let ((process-connection-type nil))
      (let ((proc (start-process "pbcopy" "*Messages*" "/usr/bin/pbcopy")))
        (process-send-string proc text)
        (process-send-eof proc))))
  (setq interprogram-cut-function 'paste-to-osx
        interprogram-paste-function 'copy-from-osx)

  (defun move-file-to-trash (file)
    "Use `trash' to move FILE to the system trash.
When using Homebrew, install it using \"brew install trash\"."
    (call-process (executable-find "trash")
                  nil 0 nil
                  file)))
#+END_SRC
** Hide minor modes from modeline
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package minions
  :ensure t
  :bind ([S-down-mouse-3] . minions-minor-modes-menu)
  :hook (after-init . minions-mode))
#+END_SRC

** Show last keybind and the function in modeline for screencasts
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package keycast
  :ensure t
  :bind ("<f9> k" . keycast-mode))
#+END_SRC

** Pairs work best together
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-insert-bracket-pair (@left-bracket @right-bracket &optional @wrap-method)
  "Insert brackets around selection, word, at point, and maybe move cursor in between.

 ,*left-bracket and *right-bracket are strings. *wrap-method must be either 'line or 'block. 'block means between empty lines.

• if there's a region, add brackets around region.
• If *wrap-method is 'line, wrap around line.
• If *wrap-method is 'block, wrap around block.
• if cursor is at beginning of line and its not empty line and contain at least 1 space, wrap around the line.
• If cursor is at end of a word or buffer, one of the following will happen:
 xyz▮ → xyz(▮)
 xyz▮ → (xyz▮)       if in one of the lisp modes.
• wrap brackets around word if any. e.g. xy▮z → (xyz▮). Or just (▮)

URL `http://ergoemacs.org/emacs/elisp_insert_brackets_by_pair.html'
Version 2017-01-17"
  (if (use-region-p)
      (progn ; there's active region
        (let (
              ($p1 (region-beginning))
              ($p2 (region-end)))
          (goto-char $p2)
          (insert @right-bracket)
          (goto-char $p1)
          (insert @left-bracket)
          (goto-char (+ $p2 2))))
    (progn ; no text selection
      (let ($p1 $p2)
        (cond
         ((eq @wrap-method 'line)
          (setq $p1 (line-beginning-position) $p2 (line-end-position))
          (goto-char $p2)
          (insert @right-bracket)
          (goto-char $p1)
          (insert @left-bracket)
          (goto-char (+ $p2 (length @left-bracket))))
         ((eq @wrap-method 'block)
          (save-excursion
            (progn
              (if (re-search-backward "\n[ \t]*\n" nil 'move)
                  (progn (re-search-forward "\n[ \t]*\n")
                         (setq $p1 (point)))
                (setq $p1 (point)))
              (if (re-search-forward "\n[ \t]*\n" nil 'move)
                  (progn (re-search-backward "\n[ \t]*\n")
                         (setq $p2 (point)))
                (setq $p2 (point))))
            (goto-char $p2)
            (insert @right-bracket)
            (goto-char $p1)
            (insert @left-bracket)
            (goto-char (+ $p2 (length @left-bracket)))))
         ( ;  do line. line must contain space
          (and
           (eq (point) (line-beginning-position))
           ;; (string-match " " (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
           (not (eq (line-beginning-position) (line-end-position))))
          (insert @left-bracket )
          (end-of-line)
          (insert  @right-bracket))
         ((and
           (or ; cursor is at end of word or buffer. i.e. xyz▮
            (looking-at "[^-_[:alnum:]]")
            (eq (point) (point-max)))
           (not (or
                 (string-equal major-mode "xah-elisp-mode")
                 (string-equal major-mode "emacs-lisp-mode")
                 (string-equal major-mode "lisp-mode")
                 (string-equal major-mode "lisp-interaction-mode")
                 (string-equal major-mode "common-lisp-mode")
                 (string-equal major-mode "clojure-mode")
                 (string-equal major-mode "xah-clojure-mode")
                 (string-equal major-mode "scheme-mode"))))
          (progn
            (setq $p1 (point) $p2 (point))
            (insert @left-bracket @right-bracket)
            (search-backward @right-bracket )))
         (t (progn
              ;; wrap around “word”. basically, want all alphanumeric, plus hyphen and underscore, but don't want space or punctuations. Also want chinese chars
              ;; 我有一帘幽梦，不知与谁能共。多少秘密在其中，欲诉无人能懂。
              (skip-chars-backward "-_[:alnum:]")
              (setq $p1 (point))
              (skip-chars-forward "-_[:alnum:]")
              (setq $p2 (point))
              (goto-char $p2)
              (insert @right-bracket)
              (goto-char $p1)
              (insert @left-bracket)
              (goto-char (+ $p2 (length @left-bracket))))))))))

(defun xah-insert-paren ()
  (interactive)
  (xah-insert-bracket-pair "(" ")") )

(defun xah-insert-bracket ()
  (interactive)
  (xah-insert-bracket-pair "[" "]") )

(defun xah-insert-brace ()
  (interactive)
  (xah-insert-bracket-pair "{" "}") )

(defun xah-insert-double-curly-quote“” () (interactive) (xah-insert-bracket-pair "“" "”") )
(defun xah-insert-curly-single-quote‘’ () (interactive) (xah-insert-bracket-pair "‘" "’") )
(defun xah-insert-single-angle-quote‹› () (interactive) (xah-insert-bracket-pair "‹" "›") )
(defun xah-insert-double-angle-quote«» () (interactive) (xah-insert-bracket-pair "«" "»") )
(defun xah-insert-ascii-double-quote () (interactive) (xah-insert-bracket-pair "\"" "\"") )
(defun xah-insert-ascii-single-quote () (interactive) (xah-insert-bracket-pair "'" "'") )
(defun xah-insert-emacs-quote () (interactive) (xah-insert-bracket-pair "`" "'") )
(defun xah-insert-corner-bracket「」 () (interactive) (xah-insert-bracket-pair "「" "」") )
(defun xah-insert-white-corner-bracket『』 () (interactive) (xah-insert-bracket-pair "『" "』") )
(defun xah-insert-angle-bracket〈〉 () (interactive) (xah-insert-bracket-pair "〈" "〉") )
(defun xah-insert-double-angle-bracket《》 () (interactive) (xah-insert-bracket-pair "《" "》") )
(defun xah-insert-white-lenticular-bracket〖〗 () (interactive) (xah-insert-bracket-pair "〖" "〗") )
(defun xah-insert-black-lenticular-bracket【】 () (interactive) (xah-insert-bracket-pair "【" "】") )
(defun xah-insert-tortoise-shell-bracket〔〕 () (interactive) (xah-insert-bracket-pair "〔" "〕") )

(global-set-key (kbd "<f8> 7") 'xah-insert-brace) ; {}
(global-set-key (kbd "<f8> 8") 'xah-insert-paren) ; ()
(global-set-key (kbd "<f8> 9") 'xah-insert-bracket) ; []
#+END_SRC
Delete bracket pairs
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-delete-backward-char-or-bracket-text ()
  "Delete backward 1 character, but if it's a \"quote\" or bracket ()[]{}【】「」 etc, delete bracket and the inner text, push the deleted text to `kill-ring'.

What char is considered bracket or quote is determined by current syntax table.

If `universal-argument' is called first, do not delete inner text.

URL `http://ergoemacs.org/emacs/emacs_delete_backward_char_or_bracket_text.html'
Version 2017-07-02"
  (interactive)
  (if (and delete-selection-mode (region-active-p))
      (delete-region (region-beginning) (region-end))
    (cond
     ((looking-back "\\s)" 1)
      (if current-prefix-arg
          (xah-delete-backward-bracket-pair)
        (xah-delete-backward-bracket-text)))
     ((looking-back "\\s(" 1)
      (progn
        (backward-char)
        (forward-sexp)
        (if current-prefix-arg
            (xah-delete-backward-bracket-pair)
          (xah-delete-backward-bracket-text))))
     ((looking-back "\\s\"" 1)
      (if (nth 3 (syntax-ppss))
          (progn
            (backward-char )
            (xah-delete-forward-bracket-pairs (not current-prefix-arg)))
        (if current-prefix-arg
            (xah-delete-backward-bracket-pair)
          (xah-delete-backward-bracket-text))))
     (t
      (delete-char -1)))))

(defun xah-delete-backward-bracket-text ()
  "Delete the matching brackets/quotes to the left of cursor, including the inner text.

This command assumes the left of point is a right bracket, and there's a matching one before it.

What char is considered bracket or quote is determined by current syntax table.

URL `http://ergoemacs.org/emacs/emacs_delete_backward_char_or_bracket_text.html'
Version 2017-07-02"
  (interactive)
  (progn
    (forward-sexp -1)
    (mark-sexp)
    (kill-region (region-beginning) (region-end))))

(defun xah-delete-backward-bracket-pair ()
  "Delete the matching brackets/quotes to the left of cursor.

After the command, mark is set at the left matching bracket position, so you can `exchange-point-and-mark' to select it.

This command assumes the left of point is a right bracket, and there's a matching one before it.

What char is considered bracket or quote is determined by current syntax table.

URL `http://ergoemacs.org/emacs/emacs_delete_backward_char_or_bracket_text.html'
Version 2017-07-02"
  (interactive)
  (let (( $p0 (point)) $p1)
    (forward-sexp -1)
    (setq $p1 (point))
    (goto-char $p0)
    (delete-char -1)
    (goto-char $p1)
    (delete-char 1)
    (push-mark (point) t)
    (goto-char (- $p0 2))))

(defun xah-delete-forward-bracket-pairs ( &optional @delete-inner-text-p)
  "Delete the matching brackets/quotes to the right of cursor.
If *delete-inner-text-p is true, also delete the inner text.

After the command, mark is set at the left matching bracket position, so you can `exchange-point-and-mark' to select it.

This command assumes the char to the right of point is a left bracket or quote, and have a matching one after.

What char is considered bracket or quote is determined by current syntax table.

URL `http://ergoemacs.org/emacs/emacs_delete_backward_char_or_bracket_text.html'
Version 2017-07-02"
  (interactive)
  (if @delete-inner-text-p
      (progn
        (mark-sexp)
        (kill-region (region-beginning) (region-end)))
    (let (($pt (point)))
      (forward-sexp)
      (delete-char -1)
      (push-mark (point) t)
      (goto-char $pt)
      (delete-char 1))))

(global-set-key (kbd "DEL") 'xah-delete-backward-char-or-bracket-text)
#+END_SRC

Select text between Quotes/Brackets
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-select-text-in-quote ()
  "Select text between the nearest left and right delimiters.
Delimiters here includes the following chars: \"<>(){}[]“”‘’‹›«»「」『』【】〖〗《》〈〉〔〕（）
This command select between any bracket chars, not the inner text of a bracket. For example, if text is

 (a(b)c▮)

 the selected char is “c”, not “a(b)c”.

URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2016-12-18"
  (interactive)
  (let (
        ($skipChars
         (if (boundp 'xah-brackets)
             (concat "^\"" xah-brackets)
           "^\"<>(){}[]“”‘’‹›«»「」『』【】〖〗《》〈〉〔〕（）"))
        $pos
        )
    (skip-chars-backward $skipChars)
    (setq $pos (point))
    (skip-chars-forward $skipChars)
    (set-mark $pos)))
#+END_SRC
Select the current line
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-select-line ()
  "Select current line. If region is active, extend selection downward by line.
URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2017-11-01"
  (interactive)
  (if (region-active-p)
      (progn
        (forward-line 1)
        (end-of-line))
    (progn
      (end-of-line)
      (set-mark (line-beginning-position)))))

(defun xah-select-current-line ()
  "Select current line.
URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2016-07-22"
  (interactive)
  (end-of-line)
  (set-mark (line-beginning-position)))
#+END_SRC
Select Current Block of text
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-select-block ()
  "Select the current/next block of text between blank lines.
If region is active, extend selection downward by block.

URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2017-11-01"
  (interactive)
  (if (region-active-p)
      (re-search-forward "\n[ \t]*\n" nil "move")
    (progn
      (skip-chars-forward " \n\t")
      (when (re-search-backward "\n[ \t]*\n" nil "move")
        (re-search-forward "\n[ \t]*\n"))
      (push-mark (point) t t)
      (re-search-forward "\n[ \t]*\n" nil "move"))))

(defun xah-select-current-block ()
  "Select the current block of text between blank lines.

URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2017-07-02"
  (interactive)
  (progn
    (skip-chars-forward " \n\t")
    (when (re-search-backward "\n[ \t]*\n" nil "move")
      (re-search-forward "\n[ \t]*\n"))
    (push-mark (point) t t)
    (re-search-forward "\n[ \t]*\n" nil "move")))
#+END_SRC

Extend Selection
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-extend-selection ()
  "Select the current word, bracket/quote expression, or expand selection.
Subsequent calls expands the selection.

when no selection,
• if cursor is on a bracket, select whole bracketed thing including bracket
• if cursor is on a quote, select whole quoted thing including quoted
• if cursor is on the beginning of line, select the line.
• else, select current word.

when there's a selection, the selection extension behavior is still experimental.
Roughly:
• if 1 line is selected, extend to next line.
• if multiple lines is selected, extend to next line.
• if a bracketed text is selected, extend to include the outer bracket. If there's no outer, select current line.

 to line, or bracket/quoted text,
or text block, whichever is the smallest.

URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2017-01-15"
  (interactive)
  (if (region-active-p)
      (progn
        (let (($rb (region-beginning)) ($re (region-end)))
          (goto-char $rb)
          (cond
           ((looking-at "\\s(")
            (if (eq (nth 0 (syntax-ppss)) 0)
                (progn
                  (message "left bracket, depth 0.")
                  (end-of-line) ; select current line
                  (set-mark (line-beginning-position)))
              (progn
                (message "left bracket, depth not 0")
                (up-list -1 t t)
                (mark-sexp))))
           ((eq $rb (line-beginning-position))
            (progn
              (goto-char $rb)
              (let (($firstLineEndPos (line-end-position)))
                (cond
                 ((eq $re $firstLineEndPos)
                  (progn
                    (message "exactly 1 line. extend to next whole line." )
                    (forward-line 1)
                    (end-of-line)))
                 ((< $re $firstLineEndPos)
                  (progn
                    (message "less than 1 line. complete the line." )
                    (end-of-line)))
                 ((> $re $firstLineEndPos)
                  (progn
                    (message "beginning of line, but end is greater than 1st end of line" )
                    (goto-char $re)
                    (if (eq (point) (line-end-position))
                        (progn
                          (message "exactly multiple lines" )
                          (forward-line 1)
                          (end-of-line))
                      (progn
                        (message "multiple lines but end is not eol. make it so" )
                        (goto-char $re)
                        (end-of-line)))))
                 (t (error "logic error 42946" ))))))
           ((and (> (point) (line-beginning-position)) (<= (point) (line-end-position)))
            (progn
              (message "less than 1 line" )
              (end-of-line) ; select current line
              (set-mark (line-beginning-position))))
           (t (message "last resort" ) nil))))
    (progn
      (cond
       ((looking-at "\\s(")
        (message "left bracket")
        (mark-sexp)) ; left bracket
       ((looking-at "\\s)")
        (message "right bracket")
        (backward-up-list) (mark-sexp))
       ((looking-at "\\s\"")
        (message "string quote")
        (mark-sexp)) ; string quote
       ((and (eq (point) (line-beginning-position)) (not (looking-at "\n")))
        (message "beginning of line and not empty")
        (end-of-line)
        (set-mark (line-beginning-position)))
       ((or (looking-back "\\s_" 1) (looking-back "\\sw" 1))
        (message "left is word or symbol")
        (skip-syntax-backward "_w" )
        ;; (re-search-backward "^\\(\\sw\\|\\s_\\)" nil t)
        (mark-sexp))
       ((and (looking-at "\\s ") (looking-back "\\s " 1))
        (message "left and right both space" )
        (skip-chars-backward "\\s " ) (set-mark (point))
        (skip-chars-forward "\\s "))
       ((and (looking-at "\n") (looking-back "\n" 1))
        (message "left and right both newline")
        (skip-chars-forward "\n")
        (set-mark (point))
        (re-search-forward "\n[ \t]*\n")) ; between blank lines, select next text block
       (t (message "just mark sexp" )
          (mark-sexp))
       ;;
       ))))
#+END_SRC

Keybindings for selecting text
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "M-6") 'xah-select-block)
(global-set-key (kbd "M-7") 'xah-select-line)
(global-set-key (kbd "M-8") 'xah-extend-selection)
(global-set-key (kbd "M-9") 'xah-select-text-in-quote)
#+END_SRC

Move cursor to brackets
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar xah-brackets nil "string of left/right brackets pairs.")
(setq xah-brackets "()[]{}<>（）［］｛｝⦅⦆〚〛⦃⦄“”‘’‹›«»「」〈〉《》【】〔〕⦗⦘『』〖〗〘〙｢｣⟦⟧⟨⟩⟪⟫⟮⟯⟬⟭⌈⌉⌊⌋⦇⦈⦉⦊❛❜❝❞❨❩❪❫❴❵❬❭❮❯❰❱❲❳〈〉⦑⦒⧼⧽﹙﹚﹛﹜﹝﹞⁽⁾₍₎⦋⦌⦍⦎⦏⦐⁅⁆⸢⸣⸤⸥⟅⟆⦓⦔⦕⦖⸦⸧⸨⸩｟｠⧘⧙⧚⧛⸜⸝⸌⸍⸂⸃⸄⸅⸉⸊᚛᚜༺༻༼༽⏜⏝⎴⎵⏞⏟⏠⏡﹁﹂﹃﹄︹︺︻︼︗︘︿﹀︽︾﹇﹈︷︸")

(defvar xah-left-brackets '("(" "{" "[" "<" "〔" "【" "〖" "〈" "《" "「" "『" "“" "‘" "‹" "«" )
  "List of left bracket chars.")
(progn
;; make xah-left-brackets based on xah-brackets
  (setq xah-left-brackets '())
  (dotimes ($x (- (length xah-brackets) 1))
    (when (= (% $x 2) 0)
      (push (char-to-string (elt xah-brackets $x))
            xah-left-brackets)))
  (setq xah-left-brackets (reverse xah-left-brackets)))

(defvar xah-right-brackets '(")" "]" "}" ">" "〕" "】" "〗" "〉" "》" "」" "』" "”" "’" "›" "»")
  "list of right bracket chars.")
(progn
  (setq xah-right-brackets '())
  (dotimes ($x (- (length xah-brackets) 1))
    (when (= (% $x 2) 1)
      (push (char-to-string (elt xah-brackets $x))
            xah-right-brackets)))
  (setq xah-right-brackets (reverse xah-right-brackets)))
(defun xah-backward-left-bracket ()
  "Move cursor to the previous occurrence of left bracket.
The list of brackets to jump to is defined by `xah-left-brackets'.
URL `http://ergoemacs.org/emacs/emacs_navigating_keys_for_brackets.html'
Version 2015-10-01"
  (interactive)
  (re-search-backward (regexp-opt xah-left-brackets) nil t))

(defun xah-forward-right-bracket ()
  "Move cursor to the next occurrence of right bracket.
The list of brackets to jump to is defined by `xah-right-brackets'.
URL `http://ergoemacs.org/emacs/emacs_navigating_keys_for_brackets.html'
Version 2015-10-01"
  (interactive)
  (re-search-forward (regexp-opt xah-right-brackets) nil t))
(global-set-key (kbd "M-m") 'xah-backward-left-bracket)
(global-set-key (kbd "M-.") 'xah-forward-right-bracket)
#+END_SRC
Jump to matching bracket
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-goto-matching-bracket ()
  "Move cursor to the matching bracket.
If cursor is not on a bracket, call `backward-up-list'.
The list of brackets to jump to is defined by `xah-left-brackets' and `xah-right-brackets'.
URL `http://ergoemacs.org/emacs/emacs_navigating_keys_for_brackets.html'
Version 2016-11-22"
  (interactive)
  (if (nth 3 (syntax-ppss))
      (backward-up-list 1 'ESCAPE-STRINGS 'NO-SYNTAX-CROSSING)
    (cond
     ((eq (char-after) ?\") (forward-sexp))
     ((eq (char-before) ?\") (backward-sexp ))
     ((looking-at (regexp-opt xah-left-brackets))
      (forward-sexp))
     ((looking-back (regexp-opt xah-right-brackets) (max (- (point) 1) 1))
      (backward-sexp))
     (t (backward-up-list 1 'ESCAPE-STRINGS 'NO-SYNTAX-CROSSING)))))

(global-set-key (kbd "M-n") 'xah-goto-matching-bracket)
#+END_SRC
** Drop down and give me 20, Magit!
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :ensure t
  :bind
  (("C-x g" . magit-status)
   :map magit-status-mode-map
   ("q". project-kill-magit-buffers))
  :init
  (defun project-kill-magit-buffers ()
    "Kill current project's magit buffers."
    (interactive)
    (when (> (count-windows) 1)
      (delete-window))
    (let ((project-magit-buffers-regexp
           (concat
            "^magit\\(?:\\|-[a-z]*\\): \\(?:"
            (regexp-quote (basename default-directory))
            "\\|"
            (regexp-quote (basename default-directory))
            "\\)")))
      (kill-matching-buffers project-magit-buffers-regexp t t))))
#+END_SRC

** Magithub, it's the hub for Magit
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magithub
  :ensure t
  :after magit
  :config
  (magithub-feature-autoinject t)
  (setq magithub-clone-default-directory "~/gitrepo"
        magithub-dir "~/.emacs.d/.cache/magithub"))
#+END_SRC

** Expand Regions
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package expand-region
  :ensure t
  :bind
  (("C-=" . er/expand-region)
   ("C-+" . er/contract-region)))
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :ensure t
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :init
  (use-package ag :ensure t)
  :config
  (progn
    (projectile-mode 1)
    (setq projectile-completion-system nil)))
#+END_SRC
** Switch Windows
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package switch-window
  :ensure t
  :bind
  (("M-\\" . switch-window)))
#+END_SRC
** Multiple cursors for when things get vulgar
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package multiple-cursors
  :ensure t
  :bind
  (("C-S-c" . mc/edit-lines)
   ("M-S-<up>" . mc/mark-previous-like-this)
   ("M-<up>" . mc/skip-to-previous-like-this)
   ("M-S-<down>" . mc/mark-next-like-this)
   ("M-<down>" . mc/skip-to-next-like-this)
   ("C-c C-<" . mc/mark-all-like-this)
   ("M-S-<mouse-1>" . mc/add-cursor-on-click)
   ("M-S-<mouse-2>" . mc/add-cursor-on-click)
   ("M-S-<mouse-3>" . mc/add-cursor-on-click)))
#+END_SRC
** Undo them trees
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-tree
  :ensure t
  :init
  (global-undo-tree-mode t))
#+END_SRC
** Make help helpful
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helpful
  :ensure t
  :bind
  (("C-h f" . helpful-callable)
   ("C-h v" . helpful-variable)
   ("C-h k" . helpful-key)))
#+END_SRC
** Edit your grep
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package wgrep :ensure t)
#+END_SRC
** Doom Themes
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package doom-themes :ensure t)
#+END_SRC
** Sidebar tree browser
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package treemacs
  :ensure t
  :bind ("<f9> t" . treemacs))
#+END_SRC
** Ewww page break characters
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package page-break-lines
  :ensure t
  :init
  (global-page-break-lines-mode t))
#+END_SRC
** Company Complete!
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :ensure t
  :hook
  (after-init . global-company-mode)
  :config
  (setq company-idle-delay 0.09
        company-minimum-prefix-length 5
        company-selection-wrap-around t
        company-show-numbers t
        company-require-match 'never
        company-dabbrev-downcase nil
        company-dabbrev-ignore-case nil
        company-backends '(company-lsp company-nxml company-cmake
                                       company-css company-capf
                                       (company-dabbrev-code company-keywords)
                                       company-files company-dabbrev)
        company-jedi-python-bin "python"))
#+END_SRC
** Buffers
*** Create a new empty buffer with the press of a key!
#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-new-empty-buffer ()
  "Create anew empty buffer.
New buffer will be named 'untitled' or 'untitled<2>', 'untitled<3>', etx.

It returns the buffer (for elisp programming).
URL `http://egroemacs.org/emacs.emacs_new_empty_buffer.html'
Version 2017-11-01"
  (interactive)
  (let (($buf (generate-new-buffer "untitled")))
    (switch-to-buffer $buf)
    (funcall initial-major-mode)
    (setq buffer-offer-save t)
    $buf
    ))
(global-set-key (kbd "<f7>") 'xah-new-empty-buffer)
#+END_SRC
** Language Server Protocol
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package lsp-mode
  :ensure t
  :init
  (progn
    (require 'lsp-imenu)
    (add-hook 'lsp-after-open-hook 'lsp-enable-imenu)
    (use-package company-lsp :ensure t)
    (use-package lsp-ui
      :ensure t
      :bind
      (:map lsp-ui-mode-map
            ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
            ([remap xref-find-references] . lsp-ui-peek-find-references)))))
#+END_SRC
** Hydra
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hydra :ensure t)
(defhydra my/hydra nil
 "
   [_s_] Skeletons
"
 ("s" my/hydra-skeleton/body :exit t)
 ("q" nil :exit t))
;; Bind the main hyrda to M-t
(global-set-key (kbd "M-t")    'my/hydra/body)

#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp :tangle yes
(when (executable-find "ipython")
  (setq python-shell-interpreter "ipython"))
(use-package pyenv-mode :ensure t)
(use-package company-jedi :ensure t)
(use-package elpy
  :ensure t
  :config
  (elpy-enable))
(use-package eglot :ensure t)
(defun ssbb-pyenv-hook ()
  "Automatically activates pyenv version if .python-version file exists."
  (f-traverse-upwards
   (lambda (path)
     (let ((pyenv-version-path (f-expand ".python-version" path)))
       (if (f-exists? pyenv-version-path)
           (pyenv-mode-set (s-trim (f-read-text pyenv-version-path 'utf-8))))))))
(add-hook 'find-file-hook 'ssbb-pyenv-hook)
#+END_SRC
** C and C++
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ccls
  :ensure t
  :commands lsp-ccls-enable
  :hook ((c++-mode c-mode) . ccls//enable)
  :init
  (defun ccls//enable ()
    (condition-case nil
        (lsp-ccls-enable)
      (user-error nil))))
#+END_SRC
** Web mode
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package web-mode
  :ensure t
  :mode ("\\.vue\\'" "\\.html\\'" "\\.htm\\'"))
#+END_SRC
** Helm
There are many helm things. I use it a lot.

A lot of things are taken from taken from
https://tuhdo.github.io/helm-intro.html

Before we load any helm things, need to load [[https://github.com/PythonNut/helm-flx][helm-flx]] so it uses flx instead of
helm's fuzzy matching. This has to happen before helm is loaded, so it goes
here.

Now we can load the big Helm configuration. Here is a breakdown of the helm
bindings I use more frequently:

| Key     | Action                                          |
|---------+-------------------------------------------------|
| M-x     | helm meta-x                                     |
| C-x C-f | helm find files                                 |
| C-x C-d | helm browse project                             |
| C-x f   | helm projectile                                 |
| C-x C-r | helm mini (includes recentf)                    |
| C-x C-o | helm occur (search in buffer)                   |
| M-y     | helm kill ring                                  |
| C-h a   | helm appropos (search functions/vars/commands)  |
| C-h m   | helm man (man pages)                            |
| C-h SPC | helm registers                                  |
| C-x b   | helm mini                                       |
| C-h t   | helm world time (show time in different places) |
| C-x C-i | helm semantic or imenu (depending on the mode)  |


#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helm-flx
  :ensure t
  :init
  (setq helm-flx-for-helm-find-files nil)
  (helm-flx-mode 1))

(use-package helm-config
  :ensure helm
  :demand t ;; demand it be loaded!
  :diminish helm-mode
  :bind
  (("C-M-z" . helm-resume)
   ("C-x C-f" . helm-find-files)
   ("C-x C-r" . helm-mini)
   ("C-x o" . helm-occur)
   ("M-y" . helm-show-kill-ring)
   ("C-h a" . helm-apropos)
   ("C-h m" . helm-man-woman)
   ("C-h SPC" . helm-all-mark-rings)
   ("C-x C-i" . helm-semantic-or-imenu)
   ("M-x" . helm-M-x)
   ("C-x C-b" . helm-buffers-list)
   ("C-x C-r" . helm-mini)
   ("C-x b" . helm-mini)
   ("C-x R" . helm-register)
   ("C-h t" . helm-world-time)
   ("M-g a" . helm-do-grep-ag)
   ("M-g p" . helm-do-ag-project-root)
   ("M-g G" . helm-grep-do-git-grep))
  :init
  (defvar my/helm-display-help-buffer-regexp '("*.*Helm.*Help.**"))
  (defvar my/helm-display-buffer-regexp
    `("*.*helm.**"
      (display-buffer-in-side-window)
      (inhibit-same-window . t)
      (side . bottom)
      (window-width . 0.6)
      (window-height . 0.4)))

  (defun my/display-helm-window (buffer &optional resume)
    "Display the Helm window."
    (let ((display-buffer-alist
           (list my/helm-display-help-buffer-regexp
                 ;; this or any specialized case of Helm buffer must be
                 ;; added AFTER `my/helm-display-buffer-regexp'.
                 ;; Otherwise, `my/helm-display-buffer-regexp' will
                 ;; be used before
                 ;; `my/helm-display-help-buffer-regexp' and display
                 ;; configuration for normal Helm buffer is applied for helm
                 ;; help buffer, making the help buffer unable to be
                 ;; displayed.
                 my/helm-display-buffer-regexp)))
      (helm-default-display-buffer buffer)))

  (setq helm-grep-default-command
        "grep -a -d skip %e -n%cH -e %p %f"
        ;; may be overridden if 'ggrep' is in path (see below)
        helm-grep-default-recurse-command
        "grep -a -d recurse %e -n%cH -e %p %f"
        ;; use CURL, not url-retrieve-synchronously
        helm-net-prefer-curl t
        ;; be idle for this many seconds, before updating in delayed sources.
        helm-input-idle-delay 0
        ;; wider buffer name in helm-buffers-list
        helm-buffer-max-length 28 ;; default is 20
        ;; instead of "..." use a smaller unicode ellipsis
        helm-buffers-end-truncated-string "…"
        ;; open helm buffer in another window
        ;;helm-split-window-default-side 'other
        ;; set to nil and use <C-backspace> to toggle it in helm-find-files
        helm-ff-auto-update-initial-value nil
        ;; if I change the resplit state, re-use my settings
        helm-reuse-last-window-split-state t
        ;; don't delete windows to always have 2
        helm-always-two-windows nil
        ;; open helm buffer inside current window, don't occupy whole other window
        helm-split-window-inside-p t
        ;; display using my function, not helm's (helm is too slow here)
        helm-display-function #'my/display-helm-window
        ;; display helm in a separate frame
        ;; helm-display-function 'helm-display-buffer-in-own-frame
        ;; reuse frame so display is faster on Emacs 26+
        ;; helm-display-buffer-reuse-frame t
        ;; helm-display-buffer-width 144
        ;; helm-display-buffer-height 24
        ;; use undecorated frame on Emacs 26+
        helm-use-undecorated-frame-option t
        ;; don't check if the file exists on remote files
        helm-buffer-skip-remote-checking t
        ;; limit the number of displayed canidates
        helm-candidate-number-limit 100
        ;; don't use recentf stuff in helm-ff, I use C-x C-r for this
        helm-ff-file-name-history-use-recentf nil
        ;; move to end or beginning of source when reaching top or bottom
        ;; of source
        helm-move-to-line-cycle-in-source t
        ;; don't display the header line
        helm-display-header-line nil
        ;; verbosity for helm tramp messages
        helm-tramp-verbose 0
        ;; fuzzy matching
        helm-recentf-fuzzy-match t
        helm-locate-fuzzy-match nil ;; locate fuzzy is worthless
        helm-M-x-fuzzy-match t
        helm-buffers-fuzzy-matching t
        helm-semantic-fuzzy-match nil
        helm-gtags-fuzzy-match nil
        helm-imenu-fuzzy-match nil
        helm-apropos-fuzzy-match nil
        helm-lisp-fuzzy-completion nil
        helm-completion-in-region-fuzzy-match nil
        ;; autoresize to 25 rows
        helm-autoresize-min-height 25
        helm-autoresize-max-height 25
        ;; Here are the things helm-mini shows, I add `helm-source-bookmarks'
        ;; here to the regular default list
        helm-mini-default-sources '(helm-source-buffers-list
                                    helm-source-recentf
                                    helm-source-bookmarks
                                    helm-source-buffer-not-found)
        ;; Reduce the list of things for helm-apropos
        helm-apropos-function-list '(helm-def-source--emacs-commands
                                     helm-def-source--emacs-functions
                                     helm-def-source--emacs-variables
                                     helm-def-source--emacs-faces))
  :config
  (use-package helm-files
    :config (setq helm-ff-file-compressed-list '("gz" "bz2" "zip" "tgz" "xz" "txz")))
  (use-package helm-buffers
    :config
    (add-to-list 'helm-boring-buffer-regexp-list "^TAGS$")
    (add-to-list 'helm-boring-buffer-regexp-list "git-gutter:diff"))
  (use-package helm-mode
    :diminish helm-mode
    :init
    (add-hook 'after-init-hook #'helm-mode)
    (add-hook 'after-init-hook #'helm-autoresize-mode)
    (add-hook 'after-init-hook #'helm-adaptive-mode)
    (add-hook 'after-init-hook #'helm-popup-tip-mode))
  (use-package helm-sys
    :init (add-hook 'after-init-hook #'helm-top-poll-mode))
  (use-package helm-grep
    :config
    (setq helm-grep-truncate-lines nil)
    (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
    (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
    (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)
    (when (executable-find "rg")
      (setq helm-grep-ag-command "rg --color=always --colors 'match:fg:black' --colors 'match:bg:yellow' --smart-case --no-heading --line-number %s %s %s"
            helm-grep-ag-pipe-cmd-switches '("--colors 'match:fg:black'" "--colors 'match:bg:yellow'"))))
  (use-package helm-man)
  (use-package helm-misc)
  (use-package helm-elisp)
  (use-package helm-imenu)
  (use-package helm-semantic)
  (use-package helm-ring)
  (use-package smex :ensure t)
  (use-package helm-smex :ensure t)
  (use-package helm-bookmark
    :bind ("C-x M-b" . helm-bookmarks))
  (use-package projectile-ripgrep :ensure t)
  (use-package helm-projectile
    :ensure t
    :demand t ;; demand it be loaded!
    :bind (:map projectile-command-map
                ("b" . helm-projectile-switch-to-buffer)
                ("d" . helm-projectile-find-dir)
                ("f" . helm-projectile-find-file)
                ("p" . helm-projectile-switch-project)
                ("s s" . helm-projectile-ag)
                ("s r" . projectile-ripgrep))
    :init
    (setq projectile-switch-project-action 'helm-projectile)
    (helm-projectile-on)
    (helm-delete-action-from-source
     "Grep in projects `C-s'"
     helm-source-projectile-projects)
    (helm-add-action-to-source
     "Ag in project C-s'"
     'helm-do-ag helm-source-projectile-projects)
    (bind-key "C-s" (defun helm-projectile-do-ag ()
                      (interactive)
                      (helm-exit-and-execute-action #'helm-do-ag))
              helm-projectile-projects-map)
    (global-set-key (kbd "C-x f") #'helm-projectile-find-file)
    :config
    (setq-default helm-truncate-lines t
                  helm-projectile-truncate-lines t))

  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))

  ;; Use popwin for helm buffers, otherwise I can't get helm to display the way
  ;; I want (at the bottom, without deleting windows)
  ;; (when (fboundp 'popwin:special-display-config)
  ;;   (push '("^\*helm.+\*$" :regexp t :height 20) popwin:special-display-config)
  ;;   (setq helm-display-function 'popwin:pop-to-buffer))

  ;; Shows helm input in the header instead of the footer
  (setq helm-echo-input-in-header-line t)
  (defun helm-hide-minibuffer-maybe ()
    "Hide minibuffer in Helm session if we use the header line as input field."
    (when (with-helm-buffer helm-echo-input-in-header-line)
      (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
        (overlay-put ov 'window (selected-window))
        (overlay-put ov 'face
                     (let ((bg-color (face-background 'default nil)))
                       `(:background ,bg-color :foreground ,bg-color)))
        (setq-local cursor-type nil))))
  (add-hook 'helm-minibuffer-set-up-hook #'helm-hide-minibuffer-maybe)

  ;; Files that helm should know how to open
  (setq helm-external-programs-associations
        '(("avi"  . "mpv")
          ("part" . "mpv")
          ("mkv"  . "mpv")
          ("webm" . "mpv")
          ("mp4"  . "mpv")))

  ;; List of times to show in helm-world-time
  (setq display-time-world-list '(("PST8PDT" "Mountain View")
                                  ("America/Denver" "Denver")
                                  ("EST5EDT" "Boston")
                                  ("UTC" "UTC")
                                  ("Europe/London" "London")
                                  ("Europe/Amsterdam" "Amsterdam")
                                  ("Asia/Bangkok" "Bangkok")
                                  ("Asia/Tokyo" "Tokyo")
                                  ("Australia/Sydney" "Sydney")))

  ;; rebind tab to do persistent action
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  ;; make TAB works in terminal
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
  ;; list actions using C-z
  (define-key helm-map (kbd "C-z")  'helm-select-action)

  (define-key helm-map (kbd "C-p")   'helm-previous-line)
  (define-key helm-map (kbd "C-n")   'helm-next-line)
  (define-key helm-map (kbd "C-M-n") 'helm-next-source)
  (define-key helm-map (kbd "C-M-p") 'helm-previous-source)
  (define-key helm-map (kbd "M-N")   'helm-next-source)
  (define-key helm-map (kbd "M-P")   'helm-previous-source)

  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  ;; ggrep is gnu grep on OSX
  (when (executable-find "ggrep")
    (setq helm-grep-default-command
          "ggrep -a -d skip %e -n%cH -e %p %f"
          helm-grep-default-recurse-command
          "ggrep -a -d recurse %e -n%cH -e %p %f"))

  ;; helm-mini instead of recentf
  (define-key 'help-command (kbd "C-f") 'helm-apropos)
  (define-key 'help-command (kbd "r") 'helm-info-emacs)

  (defvar helm-httpstatus-source
    '((name . "HTTP STATUS")
      (candidates . (("100 Continue") ("101 Switching Protocols")
                     ("102 Processing") ("200 OK")
                     ("201 Created") ("202 Accepted")
                     ("203 Non-Authoritative Information") ("204 No Content")
                     ("205 Reset Content") ("206 Partial Content")
                     ("207 Multi-Status") ("208 Already Reported")
                     ("300 Multiple Choices") ("301 Moved Permanently")
                     ("302 Found") ("303 See Other")
                     ("304 Not Modified") ("305 Use Proxy")
                     ("307 Temporary Redirect") ("400 Bad Request")
                     ("401 Unauthorized") ("402 Payment Required")
                     ("403 Forbidden") ("404 Not Found")
                     ("405 Method Not Allowed") ("406 Not Acceptable")
                     ("407 Proxy Authentication Required") ("408 Request Timeout")
                     ("409 Conflict") ("410 Gone")
                     ("411 Length Required") ("412 Precondition Failed")
                     ("413 Request Entity Too Large")
                     ("414 Request-URI Too Large")
                     ("415 Unsupported Media Type")
                     ("416 Request Range Not Satisfiable")
                     ("417 Expectation Failed") ("418 I'm a teapot")
                     ("421 Misdirected Request")
                     ("422 Unprocessable Entity") ("423 Locked")
                     ("424 Failed Dependency") ("425 No code")
                     ("426 Upgrade Required") ("428 Precondition Required")
                     ("429 Too Many Requests")
                     ("431 Request Header Fields Too Large")
                     ("449 Retry with") ("500 Internal Server Error")
                     ("501 Not Implemented") ("502 Bad Gateway")
                     ("503 Service Unavailable") ("504 Gateway Timeout")
                     ("505 HTTP Version Not Supported")
                     ("506 Variant Also Negotiates")
                     ("507 Insufficient Storage") ("509 Bandwidth Limit Exceeded")
                     ("510 Not Extended")
                     ("511 Network Authentication Required")))
      (action . message)))

  (defvar helm-clj-http-source
    '((name . "clj-http options")
      (candidates
       .
       ((":accept - keyword for content type to accept")
        (":as - output coercion: :json, :json-string-keys, :clojure, :stream, :auto or string")
        (":basic-auth - string or vector of basic auth creds")
        (":body - body of request")
        (":body-encoding - encoding type for body string")
        (":client-params - apache http client params")
        (":coerce - when to coerce response body: :always, :unexceptional, :exceptional")
        (":conn-timeout - timeout for connection")
        (":connection-manager - connection pooling manager")
        (":content-type - content-type for request")
        (":cookie-store - CookieStore object to store/retrieve cookies")
        (":cookies - map of cookie name to cookie map")
        (":debug - boolean to print info to stdout")
        (":debug-body - boolean to print body debug info to stdout")
        (":decode-body-headers - automatically decode body headers")
        (":decompress-body - whether to decompress body automatically")
        (":digest-auth - vector of digest authentication")
        (":follow-redirects - boolean whether to follow HTTP redirects")
        (":form-params - map of form parameters to send")
        (":headers - map of headers")
        (":ignore-unknown-host? - whether to ignore inability to resolve host")
        (":insecure? - boolean whether to accept invalid SSL certs")
        (":json-opts - map of json options to be used for form params")
        (":keystore - file path to SSL keystore")
        (":keystore-pass - password for keystore")
        (":keystore-type - type of SSL keystore")
        (":length - manually specified length of body")
        (":max-redirects - maximum number of redirects to follow")
        (":mime-subtype - type for multipart mime parts")
        (":multipart - vector of multipart options")
        (":oauth-token - oauth token")
        (":proxy-host - hostname of proxy server")
        (":proxy-ignore-hosts - set of hosts to ignore for proxy")
        (":proxy-post - port for proxy server")
        (":query-params - map of query parameters")
        (":raw-headers - boolean whether to return raw headers with response")
        (":response-interceptor - function called for each redirect")
        (":retry-handler - function to handle HTTP retries on IOException")
        (":save-request? - boolean to return original request with response")
        (":socket-timeout - timeout for establishing socket")
        (":throw-entire-message? - whether to throw the entire response on errors")
        (":throw-exceptions - boolean whether to throw exceptions on 5xx & 4xx")
        (":trust-store - file path to trust store")
        (":trust-store-pass - password for trust store")
        (":trust-store-type - type of trust store")))
      (action . message)))

  (defun helm-httpstatus ()
    (interactive)
    (helm-other-buffer '(helm-httpstatus-source) "*helm httpstatus*"))

  (defun helm-clj-http ()
    (interactive)
    (helm-other-buffer '(helm-clj-http-source) "*helm clj-http flags*")))

(use-package helm-ls-git
  :ensure t
  :bind ("C-x C-d" . helm-browse-project))

(use-package helm-ls-hg
  :ensure t)

(use-package helm-ag
  :ensure t)

(use-package helm-swoop
  :ensure t
  :bind (("M-i" . helm-swoop)
         ("M-I" . helm-swoop-back-to-last-point)
         ("C-c M-i" . helm-multi-swoop))
  :config
  ;; When doing isearch, hand the word over to helm-swoop
  (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
  ;; From helm-swoop to helm-multi-swoop-all
  (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
  ;; Save buffer when helm-multi-swoop-edit complete
  (setq helm-multi-swoop-edit-save t
        ;; If this value is t, split window inside the current window
        helm-swoop-split-with-multiple-windows t
        ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
        helm-swoop-split-direction 'split-window-vertically
        ;; don't auto select the thing at point
        helm-swoop-pre-input-function (lambda () "")
        ;; If nil, you can slightly boost invoke speed in exchange for text
        ;; color. If I want pretty I'll use helm-occur since it keeps colors
        helm-swoop-speed-or-color nil))
(use-package helm-descbinds
  :ensure t
  :bind ("C-h b" . helm-descbinds)
  :init (fset 'describe-bindings 'helm-descbinds))

(use-package helm-flyspell
  :ensure t
  :after helm
  :bind (:map flyspell-mode-map
              ("C-;" . helm-flyspell-correct)))

(use-package projectile
  :ensure t
  :defer 5
  :commands projectile-global-mode
  :diminish projectile-mode
  :init (add-hook 'after-init-hook #'projectile-global-mode)
  :config
  (bind-key "C-c p b" #'projectile-switch-to-buffer #'projectile-command-map)
  (bind-key "C-c p K" #'projectile-kill-buffers #'projectile-command-map)

  ;; global ignores
  (add-to-list 'projectile-globally-ignored-files ".tern-port")
  (add-to-list 'projectile-globally-ignored-files "GTAGS")
  (add-to-list 'projectile-globally-ignored-files "GPATH")
  (add-to-list 'projectile-globally-ignored-files "GRTAGS")
  (add-to-list 'projectile-globally-ignored-files "GSYMS")
  (add-to-list 'projectile-globally-ignored-files ".DS_Store")
  ;; always ignore .class files
  (add-to-list 'projectile-globally-ignored-file-suffixes ".class")
  (use-package helm-projectile
    :ensure t
    :init
    (use-package grep) ;; required for helm-ag to work properly
    (setq projectile-completion-system 'helm)
    ;; no fuzziness for projectile-helm
    (setq helm-projectile-fuzzy-match nil)
    (helm-projectile-on)
    :config
    ;; Add multi-compile to the mix for projects
    (defun helm-projectile-multi-compile-project (dir)
      "A Helm action to invoke multi-compile on a project.
`dir' is the project root."
      (let ((default-directory dir))
        (multi-compile-run)))

    ;; Add new projectile binding for multi-compile
    (helm-projectile-define-key helm-projectile-projects-map
      (kbd "M-m")  #'helm-projectile-multi-compile-project)))

#+END_SRC
** Spacemacs theme
#+BEGIN_SRC emacs-lisp :tangle yes
(install-pkgs '(spacemacs-theme))
(load-theme 'spacemacs-light)
#+END_SRC
** Yaml mode
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yaml-mode
  :ensure t)
#+END_SRC
** Groovy
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package groovy-mode
  :ensure t
  :config
  (setq groovy-indent-offset 2))
#+END_SRC
** Dired
Setup some awesome dired defaults
#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/dired-mode-hook ()
  (setq-local truncate-lines t))

(use-package dired
  :bind ("C-x C-j" . dired-jump)
  :config
  (use-package dired-x
    :init (setq-default dired-omit-files-p t)
    :config
    (add-to-list 'dired-omit-extensions ".DS_Store"))
  (customize-set-variable 'diredp-hide-details-initially-flag nil)
  (use-package dired-aux
        :init
        (use-package dired-async
          :ensure async))
      (put 'dired-find-alternate-file 'disabled nil)
      (setq ls-lisp-dirs-first t
            dired-recursive-copies 'always
            dired-recursive-deletes 'always
            dired-dwim-target t
            ;; -F marks links with @
            dired-ls-F-marks-symlinks t
            delete-by-moving-to-trash t
            ;; Don't auto refresh dired
            global-auto-revert-non-file-buffers nil
            wdired-allow-to-change-permissions t)
      (define-key dired-mode-map (kbd "C-M-u") #'dired-up-directory)
      (define-key dired-mode-map (kbd "M-o") #'my/dired-open)
      (define-key dired-mode-map (kbd "C-x C-q") #'wdired-change-to-wdired-mode)
      (bind-key "l" #'dired-up-directory dired-mode-map)
      (bind-key "M-!" #'async-shell-command dired-mode-map)
      (add-hook 'dired-mode-hook #'my/dired-mode-hook))
#+END_SRC

Quickly preview the things under the cursor
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package quick-preview
  :ensure t
  :init
  (global-set-key (kbd "C-c q") 'quick-preview-at-point)
  (define-key dired-mode-map (kbd "Q") 'quick-preview-at-point))
#+END_SRC

Pretty Icons in the dired buffers
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package all-the-icons
  :ensure t)
(use-package all-the-icons-dired
  :ensure t
  :diminish all-the-icons-dired-mode
  :init
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC

Filter dired results
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dired-narrow
  :ensure t
  :bind (:map dired-mode-map ("/" . dired-narrow)))
#+END_SRC


** Skeleton Code
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'skeleton)

(define-skeleton my/org-wrap-elisp
  "Wrap text with #+BEGIN_SRC / #+END_SRC for the emacs-lisp code"
  nil
  > "#+BEGIN_SRC emacs-lisp :tangle yes" \n
  > _ \n
  > "#+END_SRC" \n)

(define-skeleton my/org-wrap-source
  "Wrap text with #+BEGIN_SRC / #+END_SRC for a code type"
  "Language: "
  > "#+BEGIN_SRC " str ":tangle yes" \n
  > _ \n
  > "#+END_SRC" \n)

(define-skeleton my/java-try-catch
  "Wrap code in a Java try/catch"
  nil
  > "try {" \n
  > _
  > "} catch (Exception e) {" \n
  > "throw e;" \n
  > "}" \n)

(defhydra my/hydra-skeleton nil
  "Insert Skeleton"
  ("e" my/org-wrap-elisp "Wrap as elisp" :exit t)
  ("s" my/org-wrap-source "Wrap as source" :exit t)
  ("t" my/java-try-catch "Wrap with try/catch" :exit t))
#+END_SRC
** Org-mode
*** Initial configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(install-pkgs '(org-plus-contrib htmlize plantuml-mode gnuplot gnuplot-mode))
(require 'org)
(require 'org-habit)
#+END_SRC

Some things org-mode overwrites, I change them back

#+BEGIN_SRC emacs-lisp :tangle yes
(define-key org-mode-map (kbd "C-'") #'eyebrowse-next-window-config)
(define-key org-mode-map (kbd "C-c C-x C-f") #'org-refile)
(define-key org-mode-map (kbd "<C-tab>") #'other-window)
(define-key org-mode-map (kbd "C-c M-p") 'org-babel-previous-src-block)
(define-key org-mode-map (kbd "C-c M-n") 'org-babel-next-src-block)
#+END_SRC

Turn on some defaults
#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-startup-indented 'f)
(defun my/org-mode-hook ()
  (interactive)
  (setq-local fill-column 100)
  (when (fboundp 'turn-on-auto-fill)
    (turn-on-auto-fill))
  (when (fboundp 'turn-on-flyspell)
    (turn-on-flyspell))
  (when (fboundp 'yas-minor-mode)
    (yas-minor-mode 1))
  (when (fboundp 'my/enable-abbrev-mode)
    (my/enable-abbrev-mode))
  (when (boundp 'org-agenda-mode-map)
    (define-key org-agenda-mode-map (kbd "C-c C-x C-f") #'org-agenda-refile)))
#+END_SRC

Global bindings

#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "C-c l") 'org-store-link)
(global-set-key (kbd "C-c a") 'org-agenda)
(when (fboundp 'org-iswitchb)
  (global-set-key (kbd "C-c b") 'org-iswitchb))
(when (fboundp 'org-switchb)
  (global-set-key (kbd "C-c b") 'org-switchb))
(global-set-key (kbd "C-c b") 'org-iswitchb)
(global-set-key (kbd "C-c c") 'org-capture)



(add-hook 'org-mode-hook #'my/org-mode-hook)
(when (boundp 'org-export-backends)
  (custom-set-variables '(org-export-backends '(ascii beamer html latex md))))
;; Allow's electric-pair-mode to surround things with = and ~ in org-mode
(modify-syntax-entry ?~ "(~" org-mode-syntax-table)
(modify-syntax-entry ?= "(=" org-mode-syntax-table)

(setq org-directory (file-truename "~/personal/org"))

(when (file-exists-p "~/personal/org")
  (setq org-agenda-files `(,(file-truename "~/personal/org/refile.org")
                           ,(file-truename "~/personal/org/todo.org")
                           ,(file-truename "~/personal/org/digitalreasoning.org")
                           ,(file-truename "~/personal/org/learning.org")
                           ,(file-truename "~/personal/org/gratitude.org")
                           ,(file-truename "~/personal/org/notes.org")
                           ,(file-truename "~/personal/org/bibliography.org")
                           ,(file-truename "~/personal/org/journal.org")
                           ,(file-truename "~/personal/org/emacs.org")
                           ,(file-truename "~/personal/org/gcal.org")
                           ,(file-truename "~/personal/org/workgcal.org"))))

#+END_SRC

Keybindings from http://doc.norang.ca/org-mode.html

#+BEGIN_SRC emacs-lisp :tangle yes
;; Custom Key Bindings
(global-set-key (kbd "<f12>") 'org-agenda)
(global-set-key (kbd "<f5>") 'bh/org-todo)
(global-set-key (kbd "<S-f5>") 'bh/widen)
(global-set-key (kbd "<f9> <f9>") 'bh/show-org-agenda)
(global-set-key (kbd "<f9> b") 'bbdb)
(global-set-key (kbd "<f9> c") 'calendar)
(global-set-key (kbd "<f9> f") 'boxquote-insert-file)
(global-set-key (kbd "<f9> h") 'bh/hide-other)
(global-set-key (kbd "<f9> n") 'bh/toggle-next-task-display)

(global-set-key (kbd "<f9> I") 'bh/punch-in)
(global-set-key (kbd "<f9> O") 'bh/punch-out)

(global-set-key (kbd "<f9> r") 'boxquote-region)

(global-set-key (kbd "<f9> t") 'bh/insert-inactive-timestamp)
(global-set-key (kbd "<f9> T") 'bh/toggle-insert-inactive-timestamp)

(global-set-key (kbd "<f9> v") 'visible-mode)
(global-set-key (kbd "<f9> l") 'org-toggle-link-display)
(global-set-key (kbd "<f9> SPC") 'bh/clock-in-last-task)
(global-set-key (kbd "C-<f9>") 'previous-buffer)
(global-set-key (kbd "M-<f9>") 'org-toggle-inline-images)
(global-set-key (kbd "C-<f10>") 'next-buffer)
(global-set-key (kbd "<f11>") 'org-clock-goto)
(global-set-key (kbd "C-<f11>") 'org-clock-in)
(global-set-key (kbd "C-s-<f12>") 'bh/save-then-publish)
(global-set-key (kbd "C-c c") 'org-capture)

(defun bh/hide-other ()
  (interactive)
  (save-excursion
    (org-back-to-heading 'invisible-ok)
    (hide-other)
    (org-cycle)
    (org-cycle)
    (org-cycle)))
#+END_SRC

*** Tasks and States
**** Todo keywords
#+BEGIN_SRC emacs-lisp :tangle yes
;; Org todo keywords
(setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "NEEDSREVIEW(N@/!)" "|" "DONE(d)")
        (sequence "MEETING" "|" "DONE(d)")
        (sequence "WAITING(w@/!)" "HOLD(h@/!)"
                  "|" "CANCELLED(c@/!)" "MEETING")))
(setq org-todo-keyword-faces
      '(("TODO" :foreground "red" :weight bold)
        ("NEXT" :foreground "blue" :weight bold)
        ("NEEDSREVIEW" :foreground "#edd400" :weight bold)
        ("WAITING" :foreground "orange" :weight bold)
        ("HOLD" :foreground "magenta" :weight bold)
        ("DONE" :foreground "forest green" :weight bold)
        ("MEETING" :foreground "forest green" :weight bold)
        ("CANCELLED" :foreground "forest green" :weight bold)))
#+END_SRC

The following diagram shows the possible state transitions for a task. Different than BH’s because I use a NEEDSREVIEW state to indicate a pull request is waiting for review

#+BEGIN_SRC plantuml :file images/normal_task_states.png :cache yes
title Task States
[*] -> TODO
TODO -> NEXT
TODO -> NEEDSREVIEW
TODO -> WAITING
TODO -> DONE
TODO --> HOLD
TODO --> CANCELLED
NEXT -> DONE
NEXT -> NEEDSREVIEW
NEXT -> CANCELLED
NEXT --> HOLD
NEXT --> WAITING
NEEDSREVIEW -> DONE
NEEDSREVIEW -> NEXT
NEEDSREVIEW -> CANCELLED
WAITING --> TODO
WAITING --> NEXT
WAITING --> CANCELLED
HOLD --> CANCELLED
HOLD --> TODO
DONE -> [*]
CANCELLED --> [*]
TODO: t
NEXT: n
note right of NEEDSREVIEW: Note records\nlocation of review
        NEEDSREVIEW: N
        DONE: d
        note right of WAITING: Note records\nwhat it is waiting for
                WAITING:w
                note right of HOLD: Note records\nwhy it is on hold
                        HOLD:h
                        note right of CANCELLED: Note records\nwhy it was cancelled
                                CANCELLED:c
                                WAITING --> DONE
#+END_SRC

**** Project Task States

I use a lazy project definition. I don’t like to bother with manually stating ‘this is a project’ and ‘that is not a project’. For me a project definition is really simple. If a task has subtasks with a todo keyword then it’s a project. That’s it.

Projects can be defined at any level - just create a task with a todo state keyword that has at least one subtask also with a todo state keyword and you have a project. Projects use the same todo keywords as regular tasks. One subtask of a project needs to be marked NEXT so the project is not on the stuck projects list.

**** Meetings

Meetings are special. They are created in a done state by a capture task. I use the MEETING capture template when someone interrupts what I’m doing with a question or discussion. I clock the amount of time spent with whomever it is and record some notes of what was discussed (either during or after the meeting) depending on content, length, and complexity of the discussion.

The time of the meeting is recorded for as long as the capture task is active. If I need to look up other details and want to close the capture task early I can just C-c C-c to close the capture task (stopping the clock) and then f9 SPC to resume the clock in the meeting task while I do other things.

#+begin_src plantuml :file images/meeting_states.png :cache yes
title Meeting Task State
[*] -> MEETING
MEETING -> [*]
#+end_src

The setting

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

allows changing todo states with S-left and S-right skipping all of the normal processing when
entering or leaving a todo state. This cycles through the todo states but skips setting timestamps
and entering notes which is very convenient when all you want to do is fix up the status of an
entry.

**** Todo state triggers
:PROPERTIES:
:CUSTOM_ID: h:42ae1cf6-0ca0-4283-9d6f-00129c8612ce
:END:

I have a few triggers that automatically assign tags to tasks based on state changes. If a task
moves to =CANCELLED= state then it gets a =CANCELLED= tag. Moving a =CANCELLED= task back to =TODO=
removes the =CANCELLED= tag. These are used for filtering tasks in agenda views.

The triggers break down to the following rules:

- Moving a task to =CANCELLED= adds a =CANCELLED= tag
- Moving a task to =WAITING= adds a =WAITING= tag
- Moving a task to =HOLD= adds =WAITING= and =HOLD= tags
- Moving a task to =NEEDSREVIEW= adds a =REVIEW= tag
- Moving a task to a done state removes =WAITING= and =HOLD= tags
- Moving a task to =TODO= removes =WAITING=, =CANCELLED=, and =HOLD= tags
- Moving a task to =NEXT= removes =WAITING=, =CANCELLED=, and =HOLD= tags
- Moving a task to =DONE= removes =WAITING=, =CANCELLED=, and =HOLD= tags

  The tags are used to filter tasks in the agenda views conveniently.

  #+BEGIN_SRC emacs-lisp :tangle yes
(setq org-todo-state-tags-triggers
      '(("CANCELLED" ("CANCELLED" . t))
        ("WAITING" ("WAITING" . t))
        ("NEEDSREVIEW" ("REVIEW" . t))
        ("HOLD" ("WAITING") ("HOLD" . t))
        (done ("WAITING") ("HOLD") ("REVIEW"))
        ("TODO" ("WAITING") ("CANCELLED") ("HOLD") ("REVIEW"))
        ("NEXT" ("WAITING") ("CANCELLED") ("HOLD") ("REVIEW"))
        ("DONE" ("WAITING") ("CANCELLED") ("HOLD") ("REVIEW"))))
  #+END_SRC

*** Adding tasks with org capture
:PROPERTIES:
:CUSTOM_ID: h:a35f1183-5230-4d37-8ddb-9a0f91a4fd91
:END:

Org Capture mode replaces remember mode for capturing tasks and notes.

To add new tasks efficiently I use a minimal number of capture
templates.  I used to have lots of capture templates, one for each
org-file.  I'd start org-capture with =C-c c= and then pick a template
that filed the task under =* Tasks= in the appropriate file.

I found I still needed to refile these capture tasks again to the
correct location within the org-file so all of these different capture
templates weren't really helping at all.  Since then I've changed my
workflow to use a minimal number of capture templates -- I create the
new task quickly and refile it once.  This also saves me from
maintaining my org-capture templates when I add a new org file.

**** Capture Templates
:PROPERTIES:
:CUSTOM_ID: h:e89de864-0f06-4c5e-a54d-0d37e45be3b7
:END:

When a new task needs to be added I categorize it into one of a few
things:

- A meeting (m)
- An email I need to respond to (r)
- A new task (t)
- A new note (n)

  #+BEGIN_SRC emacs-lisp :tangle yes
;; Capture templates for: TODO tasks, Notes, appointments, phone calls, meetings, and org-protocol
(setq org-capture-templates
      '(("t" "Todo" entry (file "~/personal/org/refile.org")
         "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
        ("r" "respond" entry (file "~/personal/org/refile.org")
         "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n"
         :clock-in t :clock-resume t :immediate-finish t)
        ("m" "Meeting" entry (file "~/personal/org/refile.org")
         "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
        ("n" "Note" entry (file+headline "~/personal/org/notes.org" "Notes")
         "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
        ("j" "Journal" entry (file+datetree "~/personal/org/journal.org")
         "* %?\n%U\n" :clock-in t :clock-resume t)
        ("w" "org-protocol" entry (file "~/personal/org/refile.org")
         "* TODO Review %c\n%U\n" :immediate-finish t)
        ("b" "Book/Bibliography" entry
         (file+headline "~/personal/org/bibliography.org" "Refile")
         "* %?%^{TITLE}p%^{AUTHOR}p%^{TYPE}p")
        ("e" "Emacs Issues" entry (file+headline "~/personal/org/emacs.org" "Issues")
         "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)))
  #+END_SRC

  Capture mode now handles automatically clocking in and out of a capture task. This all works out of
  the box now without special hooks. When I start a capture mode task the task is clocked in as
  specified by =:clock-in t= and when the task is filed with =C-c C-c= the clock resumes on the
  original clocking task.

  The quick clocking in and out of capture mode tasks (often it takes less than a minute to capture
  some new task details) can leave empty clock drawers in my tasks which aren't really useful. Since I
  remove clocking lines with 0:00 length I end up with a clock drawer like this:

  #+begin_src org :exports src
,* TODO New Capture Task
:LOGBOOK:
:END:
[2010-05-08 Sat 13:53]
  #+end_src

  I have the following setup to remove these empty =LOGBOOK= drawers if they occur.

  #+begin_src emacs-lisp :tangle yes
;; Remove empty LOGBOOK drawers on clock out
(defun bh/remove-empty-drawer-on-clock-out ()
  (interactive)
  (save-excursion
    (beginning-of-line 0)
    (org-remove-empty-drawer-at (point))))

(add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)
  #+end_src

**** Separate files for Capture Tasks
:PROPERTIES:
:CUSTOM_ID: h:6a297830-08f4-4662-8223-8f5728d8aa93
:END:

I have a single org file which is the target for my capture templates.

I store notes, tasks, phone calls, and org-protocol tasks in =refile.org=. I used to use multiple
files but found that didn't really have any advantage over a single file.

Normally this file is empty except for a single line at the top which creates a =REFILE= tag for
anything in the file.

The file has a single permanent line at the top like this
#+begin_src org :exports src
,#+FILETAGS: REFILE
#+end_src

**** Capture Tasks is about being Fast
:PROPERTIES:
:CUSTOM_ID: h:a2a73df1-243c-406d-9677-c38da32d87f5
:END:

Okay I'm in the middle of something and oh yeah - I have to remember to do that. I don't stop what
I'm doing. I'm probably clocking a project I'm working on and I don't want to lose my focus on that
but I can't afford to forget this little thing that just came up.

So what do I do? Hit =C-c c= to start capture mode and select =t= since it's a new task and I get a
buffer like this:

#+begin_src org :exports src
,* TODO
[2010-08-05 Thu 21:06]

[[file:~/my/init-org.org::*Capture%20Tasks%20is%20about%20being%20Fast][Capture Tasks is about being Fast]]
#+end_src

Enter the details of the TODO item and =C-c C-c= to file it away in refile.org and go right back to
what I'm really working on secure in the knowledge that that item isn't going to get lost and I
don't have to think about it anymore at all now.

The amount of time I spend entering the captured note is clocked. The capture templates are set to
automatically clock in and out of the capture task. This is great for interruptions and telephone
calls too.

*** Refiling Tasks
:PROPERTIES:
:CUSTOM_ID: h:0104e42d-b6ba-48a6-ae62-d8a5c596cbe6
:END:

Refiling tasks is easy. After collecting a bunch of new tasks in my refile.org file using capture
mode I need to move these to the correct org file and topic. All of my active org-files are in my
=org-agenda-files= variable and contribute to the agenda.

I collect capture tasks in refile.org for up to a week. These now stand out daily on my block agenda
and I usually refile them during the day. I like to keep my refile task list empty.

**** Refile Setup
:PROPERTIES:
:CUSTOM_ID: RefileSetup
:END:

To refile tasks in org you need to tell it where you want to refile things.

In my setup I let any file in =org-agenda-files= and the current file contribute to the list of
valid refile targets.

I use Helm to list the refile targets. Now when I want to refile something I do =C-c C-w= to start
the refile process, then type something to get some matching targets, then

I now exclude =DONE= state tasks as valid refile targets. This helps to keep the refile target list
to a reasonable size.

#+BEGIN_SRC emacs-lisp :tangle yes
;; Targets include this file and any file contributing to the agenda - up to 9 levels deep
(setq org-refile-targets (quote ((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9))))

;; Use full outline paths for refile targets - we file directly with Helm
(setq org-refile-use-outline-path t)

;; Targets complete directly with Helm
(setq org-outline-path-complete-in-steps nil)

;; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))

 ;;;; Refile settings
;; Exclude DONE state tasks from refile targets
(defun bh/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))

(setq org-refile-target-verify-function 'bh/verify-refile-target)
#+END_SRC

**** Task Refiling
:PROPERTIES:
:CUSTOM_ID: h:d53d8043-dc5a-460d-a105-d55ee02bfee9
:END:

Tasks to refile are in their own section of the block agenda. To find tasks to refile I run my
agenda view with =M-t a= and scroll down to second section of the block agenda: =Tasks to Refile=.
This view shows all tasks (even ones marked in a =done= state).

Bulk refiling in the agenda works very well for multiple tasks going to the same place. Just mark
the tasks with =m= and then =B r= to refile all of them to a new location. Occasionally I'll also
refile tasks as subtasks of the current clocking task using =C-2 C-c C-w= from the =refile.org=
file.

Refiling all of my tasks tends to take less than a minute so I normally do this a couple of times a
day.

**** Refiling Notes
:PROPERTIES:
:CUSTOM_ID: h:6380e500-1b93-43a7-9fd3-f3076d51f8d1
:END:

I keep a =* Notes= headline in most of my org-mode files. Notes have a =NOTE= tag which is created
by the capture template for notes. This allows finding notes across multiple files easily using the
agenda search functions.

Notes created by capture tasks go first to =refile.org= and are later refiled to the appropriate
project file. Some notes that are project related get filed to the appropriate project instead of
under the catchall =* NOTES= task. Generally these types of notes are specific to the project and
not generally useful -- so removing them from the notes list when the project is archived makes
sense.

**** Refiling Phone Calls and Meetings
:PROPERTIES:
:CUSTOM_ID: RefilingMeetings
:END:

Meetings are handled using capture mode. I time my calls and meetings using the capture mode
template settings to clock in and out the capture task while the phone call or meeting is in
progress.

Meeting tasks collect in =refile.org= and are later refiled to the appropriate location.

*** Custom Agenda Views
:PROPERTIES:
:CUSTOM_ID: h:9a97e87a-3cf8-4a5d-af40-7c3af201ec34
:END:

I now have one block agenda view that has everything on it. I also keep separate single view agenda
commands for use on slower machines - since it takes prohibitively long to generate my block agenda.
I'm striving to simplify my layout with everything at my fingertips in a single agenda on my
workstation which is where I spend the bulk of my time.

Custom agenda views are used for:
- Single block agenda shows the following
  - overview of today
  - Finding tasks to be refiled
  - Finding stuck projects
  - Finding NEXT tasks to work on
  - Show all related tasks
  - Reviewing projects
  - Finding tasks waiting on something
  - Findings tasks to be archived
- Finding notes

  If I want just today's calendar view then =F12 a= is still faster than generating the block agenda -
  especially if I want to view a week or month's worth of information, or check my clocking data. In
  that case the extra detail on the block agenda view is never really needed and I don't want to spend
  time waiting for it to be generated.

  #+BEGIN_SRC emacs-lisp :tangle yes
;; Do not dim blocked tasks
(setq org-agenda-dim-blocked-tasks nil)

;; Compact the block agenda view
(setq org-agenda-compact-blocks t)

;; Custom agenda command definitions
(setq
 org-agenda-custom-commands
 (quote
  (("N" "Notes" tags "NOTE"
    ((org-agenda-overriding-header "Notes")
     (org-tags-match-list-sublevels t)))
   (" " "Agenda"
    ((agenda "" nil)
     (tags "REFILE"
           ((org-agenda-overriding-header "Tasks to Refile")
            (org-tags-match-list-sublevels nil)))
     (tags-todo "-CANCELLED/!"
                ((org-agenda-overriding-header "Stuck Projects")
                 (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                 (org-agenda-sorting-strategy
                  '(category-keep))))
     (tags-todo "-HOLD-CANCELLED/!"
                ((org-agenda-overriding-header "Projects")
                 (org-agenda-skip-function 'bh/skip-non-projects)
                 (org-tags-match-list-sublevels 'indented)
                 (org-agenda-sorting-strategy
                  '(category-keep))))
     (tags-todo "-CANCELLED/!NEXT"
                ((org-agenda-overriding-header
                  (concat "Project Next Tasks"
                          (if bh/hide-scheduled-and-waiting-next-tasks
                              ""
                            " (including WAITING and SCHEDULED tasks)")))
                 (org-agenda-skip-function
                  'bh/skip-projects-and-habits-and-single-tasks)
                 (org-tags-match-list-sublevels t)
                 (org-agenda-todo-ignore-scheduled
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-deadlines
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-with-date
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-sorting-strategy
                  '(todo-state-down effort-up category-keep))))
     (tags-todo "-REFILE-CANCELLED-WAITING-HOLD-REVIEW/!"
                ((org-agenda-overriding-header
                  (concat "Project Subtasks"
                          (if bh/hide-scheduled-and-waiting-next-tasks
                              ""
                            " (including WAITING and SCHEDULED tasks)")))
                 (org-agenda-skip-function 'bh/skip-non-project-tasks)
                 (org-agenda-todo-ignore-scheduled
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-deadlines
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-with-date
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-sorting-strategy
                  '(category-keep))))
     (tags-todo "-REFILE-CANCELLED-WAITING-HOLD-REVIEW/!"
                ((org-agenda-overriding-header
                  (concat "Standalone Tasks"
                          (if bh/hide-scheduled-and-waiting-next-tasks
                              ""
                            " (including WAITING and SCHEDULED tasks)")))
                 (org-agenda-skip-function 'bh/skip-project-tasks)
                 (org-agenda-todo-ignore-scheduled
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-deadlines
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-with-date
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-sorting-strategy
                  '(category-keep))))
     (tags-todo "-CANCELLED+WAITING|HOLD|REVIEW/!"
                ((org-agenda-overriding-header
                  (concat "Review and Waiting Tasks"
                          (if bh/hide-scheduled-and-waiting-next-tasks
                              ""
                            " (including WAITING and SCHEDULED tasks)")))
                 (org-agenda-skip-function 'bh/skip-non-tasks)
                 (org-tags-match-list-sublevels nil)
                 (org-agenda-todo-ignore-scheduled
                  bh/hide-scheduled-and-waiting-next-tasks)
                 (org-agenda-todo-ignore-deadlines
                  bh/hide-scheduled-and-waiting-next-tasks)))
     (tags "-REFILE/"
           ((org-agenda-overriding-header "Tasks to Archive")
            (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
            (org-tags-match-list-sublevels nil))))
    nil))))
  #+END_SRC

  After selecting a project (with =P= on any task in the agenda) the block agenda changes to show the
  project and any subprojects in the Projects section. Tasks show project-related tasks that are
  hidden when not narrowed to a project. This makes it easy to focus on the task at hand.

  I generally work top-down on the agenda. Things with deadlines and scheduled dates (planned to work
  on today or earlier) show up in the agenda at the top.

  My day goes generally like this:

  - Clock in (usually on the Meta task)
  - Look at the agenda and make a mental note of anything important to deal with today
  - Read email and news (clocked in to "Meta")
    - create notes, and tasks for things that need responses with org-capture
  - Check refile tasks and respond to emails
  - Look at my agenda and work on important tasks for today
    - Clock it in
    - Work on it until it is =DONE= or it gets interrupted
  - Work on tasks
  - Clock out for lunch and clock back in after lunch
  - work on more tasks
  - Refile tasks to empty the list
    - Tag tasks to be refiled with =m= collecting all tasks for the same target
    - Bulk refile the tasks to the target location with =B r=
    - Repeat (or refile individually with =C-c C-x C-f=) until all refile tasks are gone
  - Clock out at the end of the work day

*** What should I work on next?
:PROPERTIES:
:CUSTOM_ID: h:1242a154-66fe-47ec-923f-c53e4f6012b5
:END:

Start with deadlines and tasks scheduled today or earlier from the daily agenda view. Then move on
to tasks in the =Next Tasks= list in the block agenda view. I tend to schedule current projects to
'today' when I start work on them and they sit on my daily agenda reminding me that they need to be
completed. I normally only schedule one or two projects to the daily agenda and unschedule things
that are no longer important and don't deserve my attention today.

When I look for a new task to work on I generally hit =F12 SPC= to get
the block agenda and follow this order:

- Pick something off today's agenda
  - deadline for today (do this first - it's not late yet)
  - deadline in the past (it's already late)
  - a scheduled task for today (it's supposed to be done today)
  - a scheduled task that is still on the agenda
  - deadline that is coming up soon
- pick a NEXT task
- If you run out of items to work on look for a NEXT task in the current context
  pick a task from the Tasks list of the current project.

**** Why keep it all on the =NEXT= list?
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewsNextList
:END:

I've moved to a more GTD way of doing things. Now I just use a =NEXT= list. Only projects get tasks
with =NEXT= keywords since stuck projects initiate the need for marking or creating =NEXT= tasks. A
=NEXT= task is something that is available to work on /now/, it is the next logical step in some
project.

Having an agenda view that shows =NEXT= tasks makes it easy to pick the thing to clock. The =NEXT=
list is basically 'what is current' - any task that moves a project forward. I want to find the
thing to work on as fast as I can and actually do work on it - not spend time hunting through my org
files for the task that needs to be clocked-in.

To drop a task off the =NEXT= list simply move it back to the =TODO= state.

*** Reading Email, RSS, Twitter and IRC
:PROPERTIES:
:CUSTOM_ID: h:22c574a2-c9c3-44b7-8cb2-6c65a719d145
:END:

When reading email, RSS, and conversations on IRC I just let the default task (normally =* Meta=)
clock the time I spend on these tasks. To read email I go to Mu4e and read everything in my inboxes.
If there are emails that require a response I use org-capture to create a new task with a heading of
'Respond to <user>' for each one. This automatically links to the email in the task and makes it
easy to find later. Some emails are quick to respond to and some take research and a significant
amount of time to complete. I clock each one in it's own task just in case I need that clocked time
later. The capture template for Repond To tasks is now scheduled for today so I can refile the task
to the appropriate org file without losing the task for a week.

Next, I go to my newly created tasks to be refiled from the agenda with =M-t a= and clock in an
email task and deal with it. Repeat this until all of the 'Respond to <user>' tasks are marked
=DONE=.

*** Filtering
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewFiltering
:END:

So many tasks, so little time. I have lots of tasks at any given time. There is so much stuff to
look at it can be daunting. This is where agenda filtering saves the day.

It's 11:53AM and I'm in work mode just before lunch. I don't want to see tasks that are not work
related right now. I also don't want to work on a big project just before lunch... so I need to find
small tasks that I can knock off the list.

How do we do this? Get a list of NEXT tasks from the block agenda and then narrow it down with
filtering. Tasks are ordered in the NEXT agenda view by estimated effort so the short tasks are
first -- just start at the top and work your way down. I can limit the displayed agenda tasks to
those estimates of 10 minutes or less with =/ + 1= and I can pick something that fits the minutes I
have left before I take off for lunch.

**** Automatically removing context based tasks with / RET
:PROPERTIES:
:CUSTOM_ID: CustomAgendaViewFilteringContext
:END:

=/ RET= in the agenda is really useful. This awesome feature was added to org-mode by John Wiegley.
It removes tasks automatically by filtering based on a user-provided function.

At work I have projects I'm working on which are assigned by my manager. Sometimes priorities
changes and projects are delayed to sometime in the future. This means I need to stop working on
these immediately. I put the project task on =HOLD= and work on something else. The =/ RET= filter
removes =HOLD= tasks and subtasks (because of tag inheritance).

I have the following setup to allow =/ RET= to filter tasks based on the description above.

#+begin_src emacs-lisp :tangle yes
(defun bh/org-auto-exclude-function (tag)
  "Automatic task exclusion in the agenda with / RET"
  (and (cond
        ((string= tag "hold")
         t))
       (concat "-" tag)))

(setq org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)
#+end_src

This lets me filter tasks with just =/ RET= on the agenda which removes tasks I'm not supposed to be
working on now from the list of returned results.

This helps to keep my agenda clutter-free.

*** Time Clocking
:PROPERTIES:
:CUSTOM_ID: h:24165e9e-2122-44d3-ad26-aca98a7d68d3
:END:

Okay, I admit it.  I'm a clocking fanatic.

I clock everything at work. Org-mode makes this really easy. I'd rather clock too much stuff than
not enough so I find it's easier to get in the habit of clocking everything.

This makes it possible to look back at the day and see where I'm spending too much time, or not
enough time on specific projects. This also helps a lot when you need to estimate how long something
is going to take to do -- you can use your clocking data from similar tasks to help tune your
estimates so they are more accurate.

Without clocking data it's hard to tell how long something took to do after the fact.

My clocking setup basically works like this:

- Clock in to the "Meta" task
  - This clocks in a predefined task by =org-id= that is the default task to clock in whenever the
    clock normally stops
- Clock in tasks normally, and let moving to a DONE state clock out
  - clocking out automatically clocks time on a parent task or moves back to the predefined default
    task if no parent exists.
- Continue clocking whatever tasks you work on
- Clock out (stop the clock)

  I'm free to change the default task multiple times during the day but with the clock moving up the
  project tree on clock out I no longer need to do this. I simply have a single task that gets clocked
  in when I punch-in.

  If I punch-in with a prefix on a task in =Project X= then that task automatically becomes the
  default task and all clocked time goes on that project until I either punch out or punch in some
  other task.

  My org files look like this:
  =todo.org=:
  #+begin_src org :exports src
,#+FILETAGS: PERSONAL
...
,* Tasks
,** Organization
:PROPERTIES:
:CLOCK_MODELINE_TOTAL: today
:ID:       eb155a82-92b2-4f25-a3c6-0304591af2f9
:END:
...
  #+end_src

  If I am working on some task, then I simply clock in on the task. Clocking out moves the clock up to
  a parent task with a todo keyword (if any) which keeps the clock time in the same subtree. If there
  is no parent task with a todo keyword then the clock moves back to the default clocking task until I
  punch out or clock in some other task. When an interruption occurs I start a capture task which
  keeps clocked time on the interruption task until I close it with C-c C-c.

  This works really well for me.

  For example, consider the following org file:

  #+begin_src org :exports src
,* TODO Project A
,** NEXT TASK 1
,** TODO TASK 2
,** TODO TASK 3
,* Tasks
,** TODO Some miscellaneous task
  #+end_src

  I'll work on this file in the following sequence:

  1. I punch in with =F9-I= at the start of my day

     That clocks in the =Organization= task by id in my =todo.org= file.

  2. =F12-SPC= to review my block agenda

     Pick 'TODO Some miscellaneous task' to work on next and clock that in with =I= The clock is now
     on 'TODO Some miscellaneous task'

  3. I complete that task and mark it done with =C-c C-t d=

     This stops the clock and moves it back to the =Organization= task.

  4. Now I want to work on =Project A= so I clock in =Task 1=

     I work on Task 1 and mark it =DONE=. This clocks out =Task 1= and moves the clock to =Project A=.
     Now I work on =Task 2= and clock that in.

  The entire time I'm working on and clocking some subtask of =Project A= all of the clock time in the
  interval is applied somewhere to the =Project A= tree. When I eventually mark =Project A= done then
  the clock will move back to the default organization task.

*** Clock Setup
:PROPERTIES:
:CUSTOM_ID: ClockSetup
:END:

To get started we need to punch in which clocks in the default task and keeps the clock running.
This is now simply a matter of punching in the clock with =F9 I=. You can do this anywhere. Clocking
out will now clock in the parent task (if there is one with a todo keyword) or clock in the default
task if not parent exists.

Keeping the clock running when moving a subtask to a =DONE= state means clocking continues to apply
to the project task. I can pick the next task from the parent and clock that in without losing a
minute or two while I'm deciding what to work on next.

I keep clock times, state changes, and other notes in the =:LOGBOOK:= drawer.

I have the following org-mode settings for clocking:

#+begin_src emacs-lisp :tangle yes
;; Resume clocking task when emacs is restarted
(org-clock-persistence-insinuate)
;; Show lot of clocking history so it's easy to pick items off the `C-c I` list
(setq org-clock-history-length 23)
;; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)
;; Change tasks to NEXT when clocking in
(setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
;; Save clock data and state changes and notes in the LOGBOOK drawer
(setq org-clock-into-drawer t)
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks
;; with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)
;; Save the running clock and all clock history when exiting Emacs, load it on startup
(setq org-clock-persist t)
;; Do not prompt to resume an active clock
(setq org-clock-persist-query-resume nil)
;; Enable auto clock resolution for finding open clocks
(setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)
;; don't use pretty things for the clocktable
(setq org-pretty-entities nil)
;; If idle for more than 15 minutes, resolve the things by asking what to do
;; with the clock time
;;(setq org-clock-idle-time 15)

(defun my/org-clock-in ()
  (interactive)
  (org-clock-in '(4)))


(global-set-key (kbd "C-c O") #'org-clock-out)

(setq bh/keep-clock-running nil)

(defun bh/clock-in-to-next (kw)
  "Switch a task from TODO to NEXT when clocking in.
 Skips capture tasks, projects, and subprojects. Switch projects
 and subprojects from NEXT back to TODO"
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (cond
     ((and (member (org-get-todo-state) (list "TODO"))
           (bh/is-task-p))
      "NEXT")
     ((and (member (org-get-todo-state) (list "NEXT"))
           (bh/is-project-p))
      "TODO"))))

(defun bh/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))

(defun bh/punch-in (arg)
  "Start continuous clocking and set the default task to the
 selected task. If no task is selected set the Organization task
 as the default task."
  (interactive "p")
  (setq bh/keep-clock-running t)
  (if (equal major-mode 'org-agenda-mode)
      ;;
      ;; We're in the agenda
      ;;
      (let* ((marker (org-get-at-bol 'org-hd-marker))
             (tags (org-with-point-at marker (org-get-tags-at))))
        (if (and (eq arg 4) tags)
            (org-agenda-clock-in '(16))
          (bh/clock-in-organization-task-as-default)))
    ;;
    ;; We are not in the agenda
    ;;
    (save-restriction
      (widen)
                                        ; Find the tags on the current task
      (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
          (org-clock-in '(16))
        (bh/clock-in-organization-task-as-default)))))

(defun bh/punch-out ()
  (interactive)
  (setq bh/keep-clock-running nil)
  (when (org-clock-is-active)
    (org-clock-out))
  (org-agenda-remove-restriction-lock))

(defun bh/clock-in-default-task ()
  (save-excursion
    (org-with-point-at org-clock-default-task
      (org-clock-in))))

(defun bh/clock-in-parent-task ()
  "Move point to the parent (project) task if any and clock in"
  (let ((parent-task))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (if parent-task
            (org-with-point-at parent-task
              (org-clock-in))
          (when bh/keep-clock-running
            (bh/clock-in-default-task)))))))

(defvar bh/organization-task-id "a9dcbd77-e45a-44d3-82e9-80867526bd67")

(defun bh/clock-in-organization-task-as-default ()
  (interactive)
  (org-with-point-at (org-id-find bh/organization-task-id 'marker)
    (org-clock-in '(16))))

(defun bh/clock-out-maybe ()
  (when (and bh/keep-clock-running
             (not org-clock-clocking-in)
             (marker-buffer org-clock-default-task)
             (not org-clock-resolving-clocks-due-to-idleness))
    (bh/clock-in-parent-task)))

(add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)
#+end_src

I used to clock in tasks by ID using the following function but with the new punch-in and punch-out
I don't need these as much anymore. =f9-SPC= calls =bh/clock-in-last-task= which switches the clock
back to the previously clocked task.

#+begin_src emacs-lisp :tangle yes
(require 'org-id)
(defun bh/clock-in-task-by-id (id)
  "Clock in a task by id"
  (org-with-point-at (org-id-find id 'marker)
    (org-clock-in nil)))

(defun bh/clock-in-last-task (arg)
  "Clock in the interrupted task if there is one
 Skip the default task and get the next one.
 A prefix arg forces clock in of the default task."
  (interactive "p")
  (let ((clock-in-to-task
         (cond
          ((eq arg 4) org-clock-default-task)
          ((and (org-clock-is-active)
                (equal org-clock-default-task (cadr org-clock-history)))
           (caddr org-clock-history))
          ((org-clock-is-active) (cadr org-clock-history))
          ((equal org-clock-default-task (car org-clock-history)) (cadr org-clock-history))
          (t (car org-clock-history)))))
    (widen)
    (org-with-point-at clock-in-to-task
      (org-clock-in nil))))
#+end_src

*** Clocking in
:PROPERTIES:
:CUSTOM_ID: clocking-in
:END:

When I start or continue working on a task I clock it in with any of the following:

- =C-c C-x C-i=
- =I= in the agenda
- =I= speed key on the first character of the heading line
- =f9 I= while on the task in the agenda
- =f9 I= while in the task in an org file

**** Setting a default clock task
:PROPERTIES:
:CUSTOM_ID: ClockingInDefaultTask
:END:

I have a default =** Meta= task in my todo.org file that I tend to put miscellaneous clock time on.
This is the task I clock in on when I punch in at the start of my work day with =C-c I=. While
reorganizing my org-files, reading email, clearing my inbox, and doing other planning work that
isn't for a specific project I'll clock in this task. Punching-in anywhere clocks in this
Organization task as the default task.

If I want to change the default clocking task I just visit the new task in any org buffer and clock
it in with =C-c C-x C-i=. Now this new task that collects miscellaneous clock minutes when the clock
would normally stop.

You can quickly clock in the default clocking task with =C-u C-c C-x C-i d=. Another option is to
repeatedly clock out so the clock moves up the project tree until you clock out the top-level task
and the clock moves to the default task.

**** Using the clock history to clock in old tasks
:PROPERTIES:
:CUSTOM_ID: ClockingInByClockHistory
:END:

You can use the clock history to restart clocks on old tasks you've clocked or to jump directly to a
task you have clocked previously. I use this mainly to clock in whatever got interrupted by
something.

Consider the following scenario:

- You are working on and clocking =Task A= (Organization)
- You get interrupted and switch to =Task B= (Document my use of org-mode)
- You complete =Task B= (Document my use of org-mode)
- Now you want to go back to =Task A= (Organization) again to continue

  This is easy to deal with.

  1. Clock in =Task A=, work on it
  2. Go to =Task B= (or create a new task) and clock it in
  3. When you are finished with =Task B= hit =C-u C-c C-x C-i i=

  This displays a clock history selection window like the following and selects the interrupted =[i]=
  entry.

  *Clock history selection buffer for C-u C-c C-x C-i*
  #+begin_example
 Default Task
 [d] todo            Meta                                  <-- Task B
 The task interrupted by starting the last one
 [i] todo            Organization                          <-- Task B
 Current Clocking Task
 [c] org             NEXT Document my use of org-mode      <-- Task A
 Recent Tasks
 [1] org             NEXT Document my use of org-mode      <-- Task A
 [2] todo            Organization                          <-- Task B
 ...
 [Z] org             DONE Fix default section links        <-- 35 clock task entries ago
  #+end_example

*** Clock Everything - Create New Tasks
:PROPERTIES:
:CUSTOM_ID: ClockEverythingWithNewTasks
:END:

In order to clock everything you need a task for everything. That's fine for planned projects but
interruptions inevitably occur and you need some place to record whatever time you spend on that
interruption.

To deal with this we create a new capture task to record the thing we are about to do. The workflow
goes something like this:

- You are clocking some task and an interruption occurs
- Create a quick capture task journal entry =C-c c j=
- Type the heading
- go do that thing (eat lunch, whatever)
- file it =C-c C-c=, this restores the clock back to the previous clocking task
- clock something else in or continue with the current clocking task

  This means you can ignore the details like where this task really belongs in your org file layout
  and just get on with completing the thing. Refiling a bunch of tasks later in a group when it is
  convenient to refile the tasks saves time in the long run.

  If it's a one-shot uninteresting task (like a coffee break) I create a capture journal entry for it
  that goes to the diary.org date tree. If it's a task that actually needs to be tracked and marked
  done, and applied to some project then I create a capture task instead which files it in refile.org.

*** Finding tasks to clock in
:PROPERTIES:
:CUSTOM_ID: FindTasksToClockIn
:END:

To find a task to work on I use one of the following options (generally listed most frequently used
first)

- Use the clock history =C-c I=
  Go back to something I was clocking that is not finished
- Pick something off today's block agenda
  =SCHEDULED= or =DEADLINE= items that need to be done soon
- Pick something off the =NEXT= tasks agenda view
  Work on some unfinished task to move to completion
- Pick something off the other task list
- Use an agenda view with filtering to pick something to work on

  Punching in on the task you select will restrict the agenda view to that project so you can focus on
  just that thing for some period of time.

*** Editing clock entries
:PROPERTIES:
:CUSTOM_ID: EditingClockEntries
:END:

Sometimes it is necessary to edit clock entries so they reflect reality. I find I do this for maybe
2-3 entries in a week.

Occasionally I cannot clock in a task on time because I'm away from my computer. In this case the
previous clocked task is still running and counts time for both tasks which is wrong.

I make a note of the time and then when I get back to my computer I clock in the right task and edit
the start and end times to correct the clock history.

To visit the clock line for an entry quickly use the agenda log mode. =F12 a l= shows all clock
lines for today. I use this to navigate to the appropriate clock lines quickly. F11 goes to the
current clocked task but the agenda log mode is better for finding and visiting older clock entries.

Use =F12 a l= to open the agenda in log mode and show only logged clock times. Move the cursor down
to the clock line you need to edit and hit =TAB= and you're there.

To edit a clock entry just put the cursor on the part of the date you want to edit (use the keyboard
not the mouse - since the clicking on the timestamp with the mouse goes back to the agenda for that
day) and hit the =S-<up arrow>= or =S-<down arrow>= keys to change the time.

The following setting makes time editing use discrete 5-minute intervals (no rounding) increments:

#+begin_src emacs-lisp :tangle yes
(setq org-time-stamp-rounding-minutes (quote (0 5)))
#+end_src

Editing the time with the shift arrow combination also updates the total for the clock line which is
a nice convenience.

I always check that I haven't created task overlaps when fixing time clock entries by viewing them
with log mode on in the agenda. There is a new view in the agenda for this -- just hit =v c= in the
daily agenda and clock gaps and overlaps are identified.

I want my clock entries to be as accurate as possible.

The following setting shows things with > 10 minute clocking gaps.

#+begin_src emacs-lisp :tangle yes
(setq org-agenda-clock-consistency-checks
      '(:max-duration "4:00" :min-duration 0 :max-gap 10 :gap-ok-around ("4:00")))
#+end_src

*** Time reporting and tracking
:PROPERTIES:
:CUSTOM_ID: h:192ee7ba-4634-497f-b417-8e38c4d8cb51
:END:

**** Verify that the clock data is complete and correct
:PROPERTIES:
:CUSTOM_ID: h:d616c023-a1e2-4f58-9377-a4e2dc4137b4
:END:

Since I change tasks often (sometimes more than once in a minute) I use the following setting to
remove clock entries with a zero duration.

#+begin_src emacs-lisp :tangle yes
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
#+end_src

This setting just keeps my clocked log entries clean - only keeping clock entries that contribute to
the clock report.

To check for unclosed clock times I use the agenda-view clock check (=v c= in the agenda). This view
shows clocking gaps and overlaps in the agenda.

To check the last month's clock data I use =F12 a v m b v c= which shows a full month in the agenda,
moves to the previous month, and shows the clocked times only. It's important to remove any agenda
restriction locks and filters when checking the logs for gaps and overlaps.

The clocked-time only display in the agenda makes it easy to quickly scan down the list to see if an
entry is missing an end time. If an entry is not closed you can manually fix the clock entry based
on other clock info around that time.

***** Using clock reports to summarize time spent
:PROPERTIES:
:CUSTOM_ID: ClockReports
:END:

To get a report of time spent on tasks for =XYZ.org= you simply visit the =XYZ.org= file and run an
agenda clock report for the last month with =F12 < a v m b R=. This limits the agenda to this one
file, shows the agenda for a full month, moves to last month, and generates a clock report.

My agenda org clock report settings show 6 levels of detail with links
to the tasks.  I like wider reports than the default compact setting
so I override the =:narrow= value.

#+begin_src emacs-lisp :tangle yes
;; Agenda clock report parameters
(setq org-agenda-clockreport-parameter-plist
      '(:link t :maxlevel 6 :fileskip0 t :compact t :narrow 60 :score 0))
#+end_src

I have since moved to using agenda clock reports shortly after that feature was added. I find this
much more convenient. The data isn't normally for consumption by anyone else so the format of the
agenda clock report format is great for my use-case.

**** Task Estimates and column view
:PROPERTIES:
:CUSTOM_ID: TaskEstimates
:END:

Estimating how long tasks take to complete is a difficult skill to master. Org-mode makes it easy to
practice creating estimates for tasks and then clock the actual time it takes to complete.

By repeatedly estimating tasks and reviewing how your estimate relates to the actual time clocked
you can tune your estimating skills.

***** Creating a task estimate with column mode
:PROPERTIES:
:CUSTOM_ID: creating-task-estimates
:END:

I use =properties= and =column view= to do project estimates.

I set up column view globally with the following headlines

#+begin_src emacs-lisp :tangle yes
;; Set default column view headings: Task Priority Effort Clock_Summary
(setq org-columns-default-format "%50ITEM(Task) %2PRIORITY %10Effort(Effort){:} %10CLOCKSUM")
#+end_src

This makes column view show estimated task effort and clocked times side-by-side which is great for
reviewing your project estimates.

A property called =Effort= records the estimated amount of time a given task will take to complete.
The estimate times I use are one of:

- 10 minutes
- 30 minutes
- 1 hour
- 2 hours
- 3 hours
- 4 hours
- 5 hours
- 6 hours
- 7 hours
- 8 hours

  These are stored for easy use in =column mode= in the global property =Effort_ALL=.
  #+header: :tangle yes
  #+begin_src emacs-lisp :tangle yes
;; global Effort estimate values
(setq org-global-properties
      (quote (("Effort_ALL" .
               "0:15 0:30 1:00 2:00 3:00 6:00 12:00 18:00 0:00"))))
  #+end_src

  To create an estimate for a task or subtree start column mode with =C-c C-x C-c= and collapse the
  tree with =c=. This shows a table overlayed on top of the headlines with the task name, effort
  estimate, and clocked time in columns.

  With the cursor in the =Effort= column for a task you can easily set the estimated effort value with
  the quick keys =1= through =9=.

  After setting the effort values exit =column mode= with =q=.

***** Reviewing your estimate
:PROPERTIES:
:CUSTOM_ID: ReviewingEstimates
:END:

=Column view= is great for reviewing your estimate. This shows your estimated time value and the
total clock time for the project side-by-side.

Creating a dynamic clock table with =C-c C-x i RET= is a great way to save this project review if
you need to make it available to other applications.

=C-c C-x C-d= also provides a quick summary of clocked time for the current org file.

**** Providing progress reports to others
:PROPERTIES:
:CUSTOM_ID: ProgressReporting
:END:

When someone wants details of what I've done recently I simple generate a log report in the agenda
with tasks I've completed and state changes combined with a clock report for the appropriate time
period.

The following setting shows closed tasks and state changes in the agenda. Combined with the agenda
clock report ('R') I can quickly generate all of the details required.

#+header: :tangle yes
#+begin_src emacs-lisp
;; Agenda log mode items to display (closed and state changes by default)
(setq org-agenda-log-mode-items (quote (closed state)))
#+end_src

To generate the report I pull up the agenda for the appropriate time frame (today, yesterday, this
week, or last week) and hit the key sequence =l R= to add the log report (without clocking data
lines) and the agenda clock report at the end.

Then it's simply a matter of exporting the resulting agenda in some useful format to provide to
other people. =C-x C-w /tmp/agenda.html RET= exports to HTML and =C-x C-w /tmp/agenda.txt RET=
exports to plain text. Other formats are available but I use these two the most.

Combining this export with tag filters and =C-u R= can limit the report to exactly the tags that
people are interested in.

*** Tags
:PROPERTIES:
:CUSTOM_ID: tags
:END:

Tasks can have any number of arbitrary tags.  Tags are used for:

- filtering todo lists and agenda views
- providing context for tasks
- tagging notes
- tagging meetings
- tagging tasks to be refiled
- tagging tasks in a WAITING state because a parent task is WAITING
- tagging cancelled tasks because a parent task is CANCELLED
- preventing export of some subtrees when publishing

  I use tags mostly for filtering in the agenda. This means you can find tasks with a specific tag
  easily across your large number of org-mode files.

  Some tags are mutually exclusive. These are defined in a group so that only one of the tags can be
  applied to a task at a time (disregarding tag inheritance). I use these types for tags for applying
  context to a task.

  Tasks are grouped together in org-files and a =#+FILETAGS:= entry applies a tag to all tasks in the
  file. I use this to apply a tag to all tasks in the file. My refile.org file creates a REFILE file
  tag so I can filter tasks in the agenda in the refile.org file easily.

**** Tags
:PROPERTIES:
:CUSTOM_ID: OrgTagAlist
:END:

Here are my tag definitions with associated keys for filtering in the agenda views.

The startgroup - endgroup (=@XXX=) tags are mutually exclusive - selecting one removes a similar tag
already on the task. These are the context tags - you can't be in two places at once so if a task is
marked with @work and you add @home then the @work tag is removed automagically.

The other tags =WAITING= .. =FLAGGED= are not mutually exclusive and
multiple tags can appear on a single task.  Some of those tags are
created by todo state change triggers.  The shortcut key is used to
add or remove the tag using =C-c C-q= or to apply the task for
filtering on the agenda.

#+header: :tangle yes
#+begin_src emacs-lisp
;; Tags with fast selection keys
(setq org-tag-alist (quote ((:startgroup)
                            ("work" . ?w)
                            ("home" . ?h)
                            (:endgroup)
                            ("oss" . ?o)
                            ("xpack" . ?x)
                            ("book" . ?b)
                            ("support" . ?s)
                            ("docs" . ?d)
                            ("emacs" . ?e)
                            ("tech" . ?t)
                            ("noexport" . ?n)
                            ("recurring" . ?r)
                            ("WAITING" . ?W) ("HOLD" . ?H)
                            ("NOTE" . ?n) ("CANCELLED" . ?c))))

;; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)
#+end_src

**** Filetags
:PROPERTIES:
:CUSTOM_ID: FileTags
:END:

Filetags are a convenient way to apply one or more tags to all of the headings in a file.

Filetags look like this:

#+begin_src org :exports src
,#+FILETAGS: REFILE work
#+end_src

**** State Trigger Tags
:PROPERTIES:
:CUSTOM_ID: StateTriggerTags
:END:

The following tags are automatically added or removed by todo state triggers described previously in
[[#h:42ae1cf6-0ca0-4283-9d6f-00129c8612ce][Todo state triggers]]

- =REVIEW=
- =WAITING=
- =HOLD=
- =CANCELLED=

*** Handling Notes
:PROPERTIES:
:CUSTOM_ID: HandlingNotes
:END:

Notes are little gems of knowledge that you come across during your day. They are just like tasks
except there is nothing to do (except learn and memorize the gem of knowledge). Unfortunately
there are way too many gems to remember and my head explodes just thinking about it.

org-mode to the rescue!

Often I'll find some cool feature or thing I want to remember while reading the org-mode and git
mailing lists in Gnus. To create a note I use my note capture template =C-c c n=, type a heading
for the note and =C-c C-c= to save it. The only other thing to do is to refile it (later) to the
appropriate project file.

I have an agenda view just to find notes. Notes are refiled to an appropriate project file and
task. If there is no specific task it belongs to it goes to the catchall =* Notes= task. I
generally have a catchall notes task in every project file. Notes are created with a =NOTE= tag
already applied by the capture template so I'm free to refile the note anywhere. As long as the
note is in a project file that contributes to my agenda (ie. in org-agenda-files) then I can find
the note back easily with my notes agenda view by hitting the key combination =F12 N=. I'm free to
limit the agenda view of notes using standard agenda tag filtering.

Short notes with a meaningful headline are a great way to remember technical details without the
need to actually remember anything - other than how to find them back when you need them using
=F12 N=.

Notes that are project related and not generally useful can be archived with the project and
removed from the agenda when the project is removed.

*** GTD Stuff
:PROPERTIES:
:CUSTOM_ID: h:994613d4-d221-43e5-bf87-fe2be8ccd586
:END:

**** Project definition and finding stuck projects
:PROPERTIES:
:CUSTOM_ID: Projects
:END:

I'm using a new lazy project definition to mark tasks as projects. This requires zero effort from
me. Any task with a subtask using a todo keyword is a project. Period.

Projects are 'stuck' if they have no subtask with a =NEXT= todo keyword task defined.

The org-mode stuck projects agenda view lists projects that have no =NEXT= task defined. Stuck
projects show up on my block agenda and I tend to assign a =NEXT= task so the list remains empty.
This helps to keep projects moving forward.

I disable the default org-mode stuck projects agenda view with the following setting.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-stuck-projects (quote ("" nil nil "")))
#+end_src

This prevents org-mode from trying to show incorrect data if I select the default stuck project view
with =F12 #= from the agenda menu. My customized stuck projects view is part of my block agenda
displayed with =F12 SPC=.

Projects can have subprojects - and these subprojects can also be stuck. Any project that is stuck
shows up on the stuck projects list so I can indicate or create a =NEXT= task to move that project
forward.

In the following example =Stuck Project A= is stuck because it has no subtask which is =NEXT=.
=Project C= is not stuck because it has =NEXT= tasks =SubTask G= and =Task I=. =Stuck Sub Project D=
is stuck because =SubTask E= is not =NEXT= and there are no other tasks available in this project.

#+begin_src org :exports src
,* Category
,** TODO Stuck Project A
,*** TODO Task B
,** TODO Project C
,*** TODO Stuck Sub Project D
,**** TODO SubTask E
,*** TODO Sub Project F
,**** NEXT SubTask G
,**** TODO SubTask H
,*** NEXT Task I
,*** TODO Task J
#+end_src

All of the stuck projects and subprojects show up in the stuck projects list and that is my
indication to assign or create =NEXT= tasks until the stuck projects list is empty. Occasionally
some subtask is =WAITING= for something and the project is stuck until that condition is satisfied.
In this case I leave it on the stuck project list and just work on something else. This stuck
project 'bugs' me regularly when I see it on the block agenda and this prompts me to follow up on
the thing that I'm waiting for.

I have the following helper functions defined for projects which are used by agenda views.

#+begin_src emacs-lisp :tangle yes
(defun bh/is-project-p ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))

(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
 Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                              (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
          nil
        t))))

(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))

(defun bh/is-subproject-p ()
  "Any task which is a subtask of another project"
  (let ((is-subproject)
        (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
    (save-excursion
      (while (and (not is-subproject) (org-up-heading-safe))
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq is-subproject t))))
    (and is-a-task is-subproject)))

(defun bh/list-sublevels-for-projects-indented ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
   This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels 'indented)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defun bh/list-sublevels-for-projects ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
   This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels t)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defvar bh/hide-scheduled-and-waiting-next-tasks t)

(defun bh/toggle-next-task-display ()
  (interactive)
  (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
  (when  (equal major-mode 'org-agenda-mode)
    (org-agenda-redo))
  (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

(defun bh/skip-stuck-projects ()
  "Skip trees that are not stuck projects"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                nil
              next-headline)) ; a stuck project, has subtasks but no next task
        nil))))

(defun bh/skip-non-stuck-projects ()
  "Skip trees that are not stuck projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags-at))
                  (setq has-next t))))
            (if has-next
                next-headline
              nil)) ; a stuck project, has subtasks but no next task
        next-headline))))

(defun bh/skip-non-projects ()
  "Skip trees that are not projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (if (save-excursion (bh/skip-non-stuck-projects))
      (save-restriction
        (widen)
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (cond
           ((bh/is-project-p)
            nil)
           ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
            nil)
           (t
            subtree-end))))
    (save-excursion (org-end-of-subtree t))))

(defun bh/skip-project-trees-and-habits ()
  "Skip trees that are projects"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits-and-single-tasks ()
  "Skip trees that are projects, tasks that are habits, single non-project tasks"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((org-is-habit-p)
        next-headline)
       ((and bh/hide-scheduled-and-waiting-next-tasks
             (member "WAITING" (org-get-tags-at)))
        next-headline)
       ((bh/is-project-p)
        next-headline)
       ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
        next-headline)
       (t
        nil)))))

(defun bh/skip-project-tasks-maybe ()
  "Show tasks related to the current restriction.
 When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
 When not restricted, skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max))))
           (limit-to-project (marker-buffer org-agenda-restrict-begin)))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (not limit-to-project)
             (bh/is-project-subtree-p))
        subtree-end)
       ((and limit-to-project
             (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-project-tasks ()
  "Show non-project tasks.
 Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       ((bh/is-project-subtree-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-project-tasks ()
  "Show project tasks.
 Skip project and sub-project tasks, habits, and loose non-project tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       ((not (bh/is-project-subtree-p))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits ()
  "Skip trees that are projects and tasks that are habits"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-subprojects ()
  "Skip trees that are not projects"
  (let ((next-headline (save-excursion (outline-next-heading))))
    (if (bh/is-subproject-p)
        nil
      next-headline)))
#+end_src

*** Archiving
:PROPERTIES:
:CUSTOM_ID: h:60f1ef2e-f543-4296-8036-8dcb7b8379b3
:END:

**** Archiving Subtrees
:PROPERTIES:
:CUSTOM_ID: ArchivingSubtrees
:END:

My archiving procedure has changed. I used to move entire subtrees to a separate archive file for
the project. Task subtrees in =FILE.org= get archived to =FILE.org_archive= using the =a y= command
in the agenda.

I still archive to the same archive file as before but now I archive any done state todo task that
is old enough to archive. Tasks to archive are listed automatically at the end of my block agenda
and these are guaranteed to be old enough that I've already billed any time associated with these
tasks. This cleans up my project trees and removes the old tasks that are no longer interesting. The
archived tasks get extra property data created during the archive procedure so that it is possible
to reconstruct exactly where the archived entry came from in the rare case where you want to
unarchive something.

My archive files are huge but so far I haven't found a need to split them by year (or decade) :)

Archivable tasks show up in the last section of my block agenda when a new month starts. Any tasks
that are done but have no timestamps this month or last month (ie. they are over 30 days old) are
available to archive. Timestamps include closed dates, notes, clock data, etc - any active or
inactive timestamp in the task.

Archiving is trivial. Just mark all of the entries in the block agenda using the =m= key and then
archive them all to the appropriate place with =B $=. This normally takes less than 5 minutes once a
month.

**** Archive Setup
:PROPERTIES:
:CUSTOM_ID: ArchiveSetup
:END:

I no longer use an =ARCHIVE= property in my subtrees. Tasks can just archive normally to the
=Archived Tasks= heading in the archive file.

The following setting ensures that task states are untouched when they are archived. This makes it
possible to archive tasks that are not marked =DONE=. By default tasks are archived under the
heading =* Archived Tasks= in the archive file.

This archiving function does not keep your project trees intact. It archives done state tasks after
they are old enough to they are removed from the main org file. It should be possible to reconstruct
the original tree from the archive detail properties but I've never needed to do this yet. The
archived detail is very useful the few times a year I actually need to look for some archived data
but most of the time I just move it out of the way and keep it for historical purposes.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-archive-mark-done nil)
(setq org-archive-location "%s_archive::* Archived Tasks")
#+end_src

#+header: :tangle yes
#+begin_src emacs-lisp
(defun bh/skip-non-archivable-tasks ()
  "Skip trees that are not available for archiving"
  (save-restriction
    (widen)
    ;; Consider only tasks with done todo headings as archivable candidates
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
          (subtree-end (save-excursion (org-end-of-subtree t))))
      (if (member (org-get-todo-state) org-todo-keywords-1)
          (if (member (org-get-todo-state) org-done-keywords)
              (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                     (a-month-ago (* 60 60 24 (+ daynr 1)))
                     (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                     (this-month (format-time-string "%Y-%m-" (current-time)))
                     (subtree-is-current (save-excursion
                                           (forward-line 1)
                                           (and (< (point) subtree-end)
                                                (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                (if subtree-is-current
                    subtree-end ; Has a date in this month or last month, skip it
                  nil))  ; available to archive
            (or subtree-end (point-max)))
        next-headline))))
#+end_src

**** Archive Tag - Hiding Information
:PROPERTIES:
:CUSTOM_ID: ArchiveTagHidesInfo
:END:

The only time I set the ARCHIVE tag on a task is to prevent it from opening by default because it
has tons of information I don't really need to look at on a regular basis. I can open the task with
C-TAB if I need to see the gory details (like a huge table of data related to the task) but normally
I don't need that information displayed.

**** When to Archive
:PROPERTIES:
:CUSTOM_ID: WhenToArchive
:END:

Archiving monthly works well for me. I keep completed tasks around for at least 30 days before
archiving them. This keeps current clocking information for the last 30 days out of the archives.
This keeps my files that contribute to the agenda fairly current (this month, and last month, and
anything that is unfinished). I only rarely visit tasks in the archive when I need to pull up
ancient history for something.

Archiving keeps my main working files clutter-free. If I ever need the detail for the archived tasks
they are available in the appropriate archive file.

*** Publishing and Exporting
:PROPERTIES:
:CUSTOM_ID: h:df364aaf-f315-4162-ba8d-f9bb280d2b87
:END:

I don't do a lot of publishing for other people but I do keep a set of private client system
documentation online. Most of this documentation is a collection of notes exported to HTML.

Everything at [[https://writequit.org]] is generated by publishing org-files. This includes the index
pages on this site.

Org-mode can export to a variety of publishing formats including (but not limited to)

- ASCII
  (plain text - but not the original org-mode file)
- HTML
- LaTeX
- Docbook
  which enables getting to lots of other formats like ODF, XML, etc
- PDF via LaTeX or Docbook

  I use org-publishing combined with TRAMP to publish org-mode files to https://writequit.org so
  others can see them, there's a nice built in way of doing it, so I don't even have to change
  anything!

  #+BEGIN_SRC emacs-lisp :tangle yes
;; don't show the "validate" link on org-html exports
(setq org-html-validation-link nil)

;; The big list of projects
(setq org-publish-project-alist
      `(;; Main website at http://writequit.org
        ("writequit-org"
         :base-directory ,(file-truename "~/org/writequit/")
         :base-extension "org"
         :publishing-directory "/ssh:writequit.org:~/www/"
         :publishing-function org-html-publish-to-html
         :with-toc nil
         :html-preamble t
         :html-head-extra
         "<link rel=\"alternate\" type=\"application/rss+xml\"
                 href=\"https://writequit.org/posts.xml\"
                 title=\"RSS feed for writequit.org\">")
        ("writequit-rss"
         :base-directory ,(file-truename  "~/org/writequit")
         :base-extension "org"
         :publishing-directory "/ssh:writequit.org:~/www/"
         :publishing-function org-rss-publish-to-rss
         :html-link-home "http://writequit.org/"
         :exclude ".*"
         :include ("posts.org")
         :html-link-use-abs-url t)

        ;; Denver emacs site
        ("denver-emacs"
         :base-directory ,(file-truename "~/org/denver-emacs-meetup/")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/denver-emacs"
         :publishing-function org-html-publish-to-html
         :with-toc nil
         :html-preamble t)

        ;; Org-mode files for ~/.emacs.d/settings.org
        ("dotfiles"
         :base-directory ,(file-truename "~/.emacs.d/../")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/org/"
         :publishing-function org-html-publish-to-html
         :with-toc t
         :html-preamble t)

        ;; Org-mode files for ~/org files
        ("org-org"
         :base-directory ,(file-truename "~/org/")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/org/"
         :publishing-function org-html-publish-to-html
         :with-toc t
         :html-preamble t)

        ;; Org-mode for the ~/org/es files
        ("org-es-org"
         :base-directory ,(file-truename "~/org/es/")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/org/es"
         :publishing-function org-html-publish-to-html
         :with-toc t
         :html-preamble t)

        ;; Org-mode for the ~/org/es/design files
        ("org-es-design-org"
         :base-directory ,(file-truename "~/org/es/design")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/org/es/design"
         :publishing-function org-html-publish-to-html
         :with-toc t
         :html-preamble t)

        ;; Org-mode for the ~/org/es/presentations files
        ("org-es-presentations-org"
         :base-directory ,(file-truename "~/org/es/presentations")
         :base-extension "org"
         :publishing-directory
         "/ssh:writequit.org:~/www/org/es/presentations"
         :publishing-function org-html-publish-to-html
         :with-toc t
         :html-preamble t)))
  #+END_SRC

  Then, when I'm editing ~/org/es/feature-foo.org, I can hit =C-c C-e P f= and export the file to show
  up in http://p.writequit.org/org

**** exporting to Github-flavored markdown
:PROPERTIES:
:CUSTOM_ID: ox-gfm
:END:

By and large, 90% of the exports I do are to Github's markdown. Usually to share for an issue. So
there's a nice exporter that does this for me: =ox-gfm=. While Github does support org-mode as a
file format (or in gists), it doesn't support org syntax in the body of issues or PR comments, so I
need a way to generate that syntax.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ox-gfm
  :ensure t
  :init
  (when (boundp 'org-export-backends)
    (customize-set-variable 'org-export-backends
                            (cons 'gfm org-export-backends))))
#+END_SRC

**** exporting to tufte html
:PROPERTIES:
:CUSTOM_ID: h:456bf59e-a548-4e53-b7dc-2c8c868029fe
:END:

I wrote [[https://github.com/dakrone/ox-tufte][a project]] to do this, and even though it's available on MELPA, it's still useful to be able
to use the development (read: local) version of it when available.

#+BEGIN_SRC emacs-lisp :tangle yes
(if (file-exists-p "~/src/elisp/ox-tufte")
    (progn
      (add-to-list 'load-path "~/src/elisp/ox-tufte")
      (require 'ox-tufte))
  (use-package ox-tufte
    :ensure t
    :init (require 'ox-tufte)))
#+END_SRC

*** Org Babel
#+BEGIN_SRC emacs-lisp :tangle yes
;; org-babel stuff
(defadvice org-babel-execute-src-block (around load-language nil activate)
  "Load language if needed"
  (let ((language (org-element-property :language (org-element-at-point))))
    (unless (cdr (assoc (intern language) org-babel-load-languages))
      (add-to-list 'org-babel-load-languages (cons (intern language) t))
      (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
    ad-do-it))


;; don't run stuff automatically on export
(setq org-export-babel-evaluate nil
      ;; always enable noweb, results as code and exporting both
      org-babel-default-header-args
      (cons '(:noweb . "yes")
            (assq-delete-all :noweb org-babel-default-header-args))
      org-babel-default-header-args
      (cons '(:exports . "both")
            (assq-delete-all :exports org-babel-default-header-args))
      ;; I don't want to be prompted on every code block evaluation
      org-confirm-babel-evaluate nil)

;; Load the languages we want to allow execution of
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (shell . t)
   (ruby . t)
   (python . t)))

;; this is where Fedora installs it, YMMV
(setq org-plantuml-jar-path "~/personal/bin/plantuml.jar")
(setq plantuml-jar-path "~/personal/bin/plantuml.jar")

;; Use org.css from the :wq website for export document stylesheets
(setq org-html-head-include-default-style nil)

;; ensure this variable is defined
(unless (boundp 'org-babel-default-header-args:sh)
  (setq org-babel-default-header-args:sh '()))

;; add a default shebang header argument shell scripts
(add-to-list 'org-babel-default-header-args:sh
             '(:shebang . "#!/usr/bin/env bash"))

;; add a default shebang header argument for python
(add-to-list 'org-babel-default-header-args:python
             '(:shebang . "#!/usr/bin/env python"))

;; Make babel results blocks lowercase
(setq org-babel-results-keyword "results")

;; Automatically show images after execution
(defun bh/display-inline-images ()
  (condition-case nil
      (org-display-inline-images)
    (error nil)))
(add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
;; Don't enable this because it breaks access to emacs from my Android phone
(setq org-startup-with-inline-images nil)
#+END_SRC

Allow asynchronously executing org-babel blocks. Sometimes I run long-running
babel executions, and this allows Emacs not to hang while executing them
#+BEGIN_SRC emacs-lisp :tangle yes
(eval-after-load "org"
  (use-package ob-async
    :ensure t
    :disabled t
    :init (require 'ob-async)))
#+END_SRC

*** Reminders
:PROPERTIES:
:CUSTOM_ID: Reminders
:END:

I use appt for reminders.  It's simple and unobtrusive -- putting
pending appointments in the status bar and beeping as 12, 9, 6, 3,
and 0 minutes before the appointment is due.

Everytime the agenda is displayed (and that's lots for me) the
appointment list is erased and rebuilt from the current agenda
details for today.  This means everytime I reschedule something, add
or remove tasks that are time related the appointment list is
automatically updated the next time I look at the agenda.

**** Reminder Setup
:PROPERTIES:
:CUSTOM_ID: ReminderSetup
:END:

#+begin_src emacs-lisp :tangle yes
(setq appt-message-warning-time 15
      appt-display-interval 5)

;; Erase all reminders and rebuilt reminders for today from the agenda
(defun bh/org-agenda-to-appt ()
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))

;; Rebuild the reminders everytime the agenda is displayed
(add-hook 'org-finalize-agenda-hook 'bh/org-agenda-to-appt 'append)

;; This is at the end of my .emacs - so appointments are set up when Emacs starts
;;(bh/org-agenda-to-appt)

;; Activate appointments so we get notifications
(appt-activate t)

;; If we leave Emacs running overnight - reset the appointments one minute after midnight
(run-at-time "24:01" nil 'bh/org-agenda-to-appt)
#+end_src

**** Automatically save org-mode files
:PROPERTIES:
:CUSTOM_ID: h:594541f3-7d46-4163-a1c6-77f30e8f02d4
:END:

#+BEGIN_SRC emacs-lisp :tangle yes
;; Automatically save all org files every minute
(run-at-time "00:59" 3600 'org-save-all-org-buffers)
#+END_SRC

*** Org-mode look & feel
:PROPERTIES:
:CUSTOM_ID: h:e0386813-3caf-4ffe-b5e2-c7be2e029fe5
:END:

**** Tweaking the various org settings
:PROPERTIES:
:CUSTOM_ID: h:a6e2c173-2368-452b-b9e8-4687916381b0
:END:

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-return-follows-link t ;; follow links by pressing ENTER on them
      ;; syntax highlight code in source blocks
      org-src-fontify-natively t
      ;; for the leuven theme, fontify the whole heading line
      org-fontify-whole-heading-line t
      ;; force UTF-8
      org-export-coding-system 'utf-8
      ;; don't start up org files with indentation
      ;; (same as #+STARTUP: noindent)
      org-startup-indented t
      ;; *don't* hide things like = and / for emphasis markers
      org-hide-emphasis-markers nil
      ;; don't indent source code
      org-edit-src-content-indentation 0
      ;; don't adapt indentation
      org-adapt-indentation nil
      ;; preserve the indentation inside of source blocks
      org-src-preserve-indentation t
      ;; Imenu should use 3 depth instead of 2
      org-imenu-depth 3
      ;; Use inline footnotes by default
      org-footnote-define-inline t
      ;; put state change log messages into a drawer
      org-log-into-drawer t
      ;; special begin/end of line to skip tags and stars
      org-special-ctrl-a/e t
      ;; special keys for killing a headline
      org-special-ctrl-k t
      ;; don't adjust subtrees that I copy
      org-yank-adjusted-subtrees nil
      ;; try to be smart when editing hidden things
      org-catch-invisible-edits 'smart
      ;; blank lines are removed when exiting the code edit buffer
      org-src-strip-leading-and-trailing-blank-lines t
      ;; how org-src windows are set up when hitting C-c '
      org-src-window-setup 'current-window
      ;; leave this many empty lines in collapsed view
      org-cycle-separator-lines 2
      ;; export tables as CSV instead of tab-delineated
      org-table-export-default-format "orgtbl-to-csv"
      ;; use #+ATTR: if defined, or real width otherwise
      org-image-actual-width nil)

;; org-mode bindings
(define-key org-mode-map (kbd "C-c t") 'org-todo)
(define-key org-mode-map (kbd "RET") 'org-return-indent)
#+END_SRC

This makes the bullets into fancy Unicode bullets, rather than ASCII '*' values. Depending on the
theme, it may look better or worse. I also customize the list of bullets because the defaults are a
little wonky looking.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-bullets
  :ensure t
  :init
  (setq org-bullets-bullet-list '("✸" "•" "◦" "•" "◦" "•" "◦"))
  (add-hook 'org-mode-hook #'org-bullets-mode))
#+END_SRC

**** Automatically making source code background the same color as the theme
:PROPERTIES:
:CUSTOM_ID: h:a48460d4-f1d4-40c0-9627-bbc71c500db4
:END:

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/org-inline-css-hook (exporter)
  "Insert custom inline css to automatically set the
    background of code to whatever theme I'm using's background"
  (when (eq exporter 'html)
    (let* ((my-pre-bg (face-background 'default))
           (my-pre-fg (face-foreground 'default)))
      ;;(setq org-html-head-include-default-style nil)
      (setq
       org-html-head-extra
       (concat
        org-html-head-extra
        (format
         "<style type=\"text/css\">\n pre.src {background-color: %s; color: %s;}</style>\n"
         my-pre-bg my-pre-fg))))))

#+END_SRC

Uncomment to automatically set background color to theme background

#+BEGIN_SRC emacs-lisp :tangle yes
;; (add-hook 'org-export-before-processing-hook #'my/org-inline-css-hook)
#+END_SRC

**** Automatically adding CUSTOM_ID to headlines in a file
:PROPERTIES:
:CUSTOM_ID: h:abeafd05-8947-4ee7-9786-5d665a77873b
:END:

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-id
  :init
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

  (defun my/org-custom-id-get (&optional pom create prefix)
    "Get the CUSTOM_ID property of the entry at point-or-marker POM.
       If POM is nil, refer to the entry at point. If the entry does
       not have an CUSTOM_ID, the function returns nil. However, when
       CREATE is non nil, create a CUSTOM_ID if none is present
       already. PREFIX will be passed through to `org-id-new'. In any
       case, the CUSTOM_ID of the entry is returned."
    (interactive)
    (org-with-point-at pom
      (let ((id (org-entry-get nil "CUSTOM_ID")))
        (cond
         ((and id (stringp id) (string-match "\\S-" id))
          id)
         (create
          (setq id (org-id-new (concat prefix "h")))
          (org-entry-put pom "CUSTOM_ID" id)
          (org-id-add-location id (buffer-file-name (buffer-base-buffer)))
          id)))))

  (defun my/org-add-ids-to-headlines-in-file ()
    "Add CUSTOM_ID properties to all headlines in the current
       file which do not already have one. Only adds ids if the
       `auto-id' option is set to `t' in the file somewhere. ie,
       ,#+OPTIONS: auto-id:t"
    (interactive)
    (save-excursion
      (widen)
      (goto-char (point-min))
      (when (re-search-forward "^#\\+OPTIONS:.*auto-id:t" (point-max) t)
        (org-map-entries (lambda () (my/org-custom-id-get (point) 'create))))))

  ;; automatically add ids to saved org-mode headlines
  (add-hook 'org-mode-hook
            (lambda ()
              (add-hook 'before-save-hook
                        (lambda ()
                          (when (and (eq major-mode 'org-mode)
                                     (eq buffer-read-only nil))
                            (my/org-add-ids-to-headlines-in-file)))))))
#+END_SRC

**** Tuning the way Agenda looks
:PROPERTIES:
:CUSTOM_ID: h:9675c2c2-6262-44f3-bf7b-2a053daaacbf
:END:

***** Keep tasks with timestamps visible on the global todo lists
:PROPERTIES:
:CUSTOM_ID: GlobalTodoListsShowAllTasks
:END:

Tasks with dates (=SCHEDULED:=, =DEADLINE:=, or active dates) show up in the agenda when
appropriate. The block agenda view (=F12 a=) tries to keep tasks showing up only in one location
(either in the calendar or other todo lists in later sections of the block agenda.) I now rarely use
the global todo list search in org-mode (=F12 t=, =F12 m=) and when I do I'm trying to find a
specific task quickly. These lists now include _everything_ so I can just search for the item I want
and move on.

The block agenda prevents display of tasks with deadlines or scheduled dates in the future so you
can safely ignore these until the appropriate time.

#+begin_src emacs-lisp :tangle yes
;; Keep tasks with dates on the global todo lists
(setq org-agenda-todo-ignore-with-date nil)

;; Keep tasks with deadlines on the global todo lists
(setq org-agenda-todo-ignore-deadlines nil)

;; Keep tasks with scheduled dates on the global todo lists
(setq org-agenda-todo-ignore-scheduled nil)

;; Keep tasks with timestamps on the global todo lists
(setq org-agenda-todo-ignore-timestamp nil)

;; Remove completed deadline tasks from the agenda view
(setq org-agenda-skip-deadline-if-done t)

;; Remove completed scheduled tasks from the agenda view
(setq org-agenda-skip-scheduled-if-done t)

;; Remove completed items from search results
(setq org-agenda-skip-timestamp-if-done t)
#+end_src

***** Use the Diary for Holidays and Appointments
:PROPERTIES:
:CUSTOM_ID: DiaryForAppointments
:END:

I don't use the emacs Diary for anything other than birthdays but I like seeing the holidays on my
agenda. This helps with planning for those days when you're not supposed to be working.

#+header: :tangle yes
#+begin_src emacs-lisp
(setq org-agenda-include-diary t)
(setq org-agenda-diary-file "~/diary")
#+end_src

The diary file keeps =date-tree= entries created by the capture mode 'appointment' template. I use
this also for miscellaneous tasks I want to clock during interruptions.

I don't use a =~/diary= file anymore. That is just there as a zero-length file to keep Emacs happy.
I use org-mode's diary functions instead. Inserting entries with =i= in the emacs agenda creates
date entries in the =~/git/org/diary.org= file.

I include holidays from the calendar in my =todo.org= file as follows:

#+begin_src org :exports src
,#+FILETAGS: PERSONAL
,* Appointments
:PROPERTIES:
:CATEGORY: Appt
:ARCHIVE:  %s_archive::* Appointments
:END:
,** Holidays
:PROPERTIES:
:Category: Holiday
:END:
%%(org-calendar-holiday)
,** Some other Appointment
...
#+end_src

I use the following setting so any time strings in the heading are shown in the agenda.

#+begin_src emacs-lisp :tangle yes
(setq org-agenda-insert-diary-extract-time t)
#+end_src

***** Searches include archive files
:PROPERTIES:
:CUSTOM_ID: SearchesIncludeArchiveFiles
:END:

I keep a single archive file for each of my org-mode project files. This allows me to search the
current file and the archive when I need to dig up old information from the archives.

I don't need this often but it sure is handy on the occasions that I do need it.

#+begin_src emacs-lisp :tangle yes
;; Include agenda archive files when searching for things
(setq org-agenda-text-search-extra-files (quote (agenda-archives)))
#+end_src

***** Agenda view tweaks
:PROPERTIES:
:CUSTOM_ID: AgendaViewTweaks
:END:

The following agenda customizations control
- display of repeating tasks
- display of empty dates on the agenda
- task sort order
- start the agenda weekly view with Sunday
- display of the grid
- habits at the bottom

  I use a custom sorting function so that my daily agenda lists tasks in order of importance. Tasks on
  the daily agenda are listed in the following order:

  1. tasks with times at the top so they are hard to miss
  2. entries for today (active timestamp headlines that are not scheduled or deadline tasks)
  3. deadlines due today
  4. late deadline tasks
  5. scheduled items for today
  6. pending deadlines (due soon)
  7. late scheduled items
  8. habits

  The lisp for this isn't particularly pretty but it works.

  Here are the =.emacs= settings:

  #+begin_src emacs-lisp :tangle yes
;; Show all future entries for repeating tasks
(setq org-agenda-repeating-timestamp-show-all t)

;; Show all agenda dates - even if they are empty
(setq org-agenda-show-all-dates t)

;; Sorting order for tasks on the agenda
(setq org-agenda-sorting-strategy
      '((agenda habit-down time-up priority-down
                user-defined-up effort-up category-keep)
        (todo category-up effort-up)
        (tags category-up effort-up)
        (search category-up)))

;; Enable display of the time grid so we can see the marker for the current time
(setq org-agenda-time-grid
      '((daily today remove-match)
        (0900 1100 1300 1500 1700)
        "......"
        "----------------"))

;; Display tags farther right
(setq org-agenda-tags-column -110
      ;; keep the agenda filter until manually removed
      org-agenda-persistent-filter t
      ;; show all occurrences of repeating tasks
      org-agenda-repeating-timestamp-show-all t
      ;; always start the agenda on Monday
      org-agenda-start-on-weekday 1
      ;; show 1 agenda days
      org-agenda-span 1
      ;; Do not dim blocked tasks
      org-agenda-dim-blocked-tasks nil
      ;; include the diary in the agenda
      org-agenda-include-diary t
      ;; Compact the block agenda view
      org-agenda-compact-blocks t
      ;; Show all agenda dates - even if they are empty
      org-agenda-show-all-dates t
      ;; Overwrite the current window with the agenda
      org-agenda-window-setup 'current-window)

;;
;; Agenda sorting functions
;;
(setq org-agenda-cmp-user-defined 'bh/agenda-sort)

(defun bh/agenda-sort (a b)
  "Sorting strategy for agenda items.
 Late deadlines first, then scheduled, then non-late deadlines"
  (let (result num-a num-b)
    (cond
     ;; time specific items are already sorted first by org-agenda-sorting-strategy
     ;; non-deadline and non-scheduled items next
     ((bh/agenda-sort-test 'bh/is-not-scheduled-or-deadline a b))
     ;; deadlines for today next
     ((bh/agenda-sort-test 'bh/is-due-deadline a b))
     ;; late deadlines next
     ((bh/agenda-sort-test-num 'bh/is-late-deadline '> a b))
     ;; scheduled items for today next
     ((bh/agenda-sort-test 'bh/is-scheduled-today a b))
     ;; late scheduled items next
     ((bh/agenda-sort-test-num 'bh/is-scheduled-late '> a b))
     ;; pending deadlines last
     ((bh/agenda-sort-test-num 'bh/is-pending-deadline '< a b))
     ;; finally default to unsorted
     (t (setq result nil)))
    result))

(defmacro bh/agenda-sort-test (fn a b)
  "Test for agenda sort"
  `(cond
    ;; if both match leave them unsorted
    ((and (apply ,fn (list ,a))
          (apply ,fn (list ,b)))
     (setq result nil))
    ;; if a matches put a first
    ((apply ,fn (list ,a))
     (setq result -1))
    ;; otherwise if b matches put b first
    ((apply ,fn (list ,b))
     (setq result 1))
    ;; if none match leave them unsorted
    (t nil)))

(defmacro bh/agenda-sort-test-num (fn compfn a b)
  `(cond
    ((apply ,fn (list ,a))
     (setq num-a (string-to-number (match-string 1 ,a)))
     (if (apply ,fn (list ,b))
         (progn
           (setq num-b (string-to-number (match-string 1 ,b)))
           (setq result (if (apply ,compfn (list num-a num-b))
                            -1
                          1)))
       (setq result -1)))
    ((apply ,fn (list ,b))
     (setq result 1))
    (t nil)))

(defun bh/is-not-scheduled-or-deadline (date-str)
  (and (not (bh/is-deadline date-str))
       (not (bh/is-scheduled date-str))))

(defun bh/is-due-deadline (date-str)
  (string-match "Deadline:" date-str))

(defun bh/is-late-deadline (date-str)
  (string-match "\\([0-9]*\\) d\. ago:" date-str))

(defun bh/is-pending-deadline (date-str)
  (string-match "In \\([^-]*\\)d\.:" date-str))

(defun bh/is-deadline (date-str)
  (or (bh/is-due-deadline date-str)
      (bh/is-late-deadline date-str)
      (bh/is-pending-deadline date-str)))

(defun bh/is-scheduled (date-str)
  (or (bh/is-scheduled-today date-str)
      (bh/is-scheduled-late date-str)))

(defun bh/is-scheduled-today (date-str)
  (string-match "Scheduled:" date-str))

(defun bh/is-scheduled-late (date-str)
  (string-match "Sched\.\\(.*\\)x:" date-str))
  #+end_src
*** Presentations in Org-mode
:PROPERTIES:
:CUSTOM_ID: h:b456458e-3a2c-4a4e-9913-3e3f6d2eed7c
:END:

There are a bunch of different ways to present things

**** Presentations with beamer
:PROPERTIES:
:CUSTOM_ID: h:a40400bb-3995-4963-9e45-183f1822e172
:END:

Beamer is actually built-into org-mode, but requires a few extra libraries I wanted to document
here:

- texlive
- texlive-latex
- texlive-wrapfig
- texlive-ulem
- texlive-capt-of
- texlive-minted

  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ox-latex
  :config
  (add-to-list 'org-latex-packages-alist '("" "minted" nil))
  (setq org-latex-listings 'minted)
  (setq
   org-latex-pdf-process
   '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")))
  #+END_SRC

**** Presentations with org-present
:PROPERTIES:
:CUSTOM_ID: h:8a107aa5-26dc-4db0-b868-dd937a57cb6c
:END:

A simple presentation mode for org-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-present
  :ensure t
  :defer 20
  :init
  (add-hook 'org-present-mode-hook
            (lambda ()
              (org-present-big)
              (org-display-inline-images)
              (org-present-hide-cursor)
              (org-present-read-only)))
  (add-hook 'org-present-mode-quit-hook
            (lambda ()
              (org-present-small)
              (org-remove-inline-images)
              (org-present-show-cursor)
              (org-present-read-write))))
#+END_SRC

**** Presentations with =epresent=
:PROPERTIES:
:CUSTOM_ID: epresent
:END:

Right now the default keybindings are annoying

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package epresent
  :ensure t
  :disabled t)
#+END_SRC

**** Presentations with =org-reveal=
https://github.com/yjwen/org-reveal
:PROPERTIES:
:CUSTOM_ID: h:3c34dc2c-3334-4f44-8cce-facef8541c5a
:END:

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ox-reveal
  :ensure t
  :config
  (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/"))
#+END_SRC

*** Org Brain
:PROPERTIES:
:CUSTOM_ID: h:ffb95129-c50e-41fc-86ab-c9b5e6541dfc
:END:

TODO: document me

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-brain
  :ensure t)
#+END_SRC

*** Deft
I use deft to take quick notes and search through those notes

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package deft
  :ensure t
  :bind ("C-x t" . deft)
  :config
  (setq deft-extension '("org" "txt" "tex" "text" "md")
        deft-directory "~/personal/org/deft/"
        deft-recursive t
        deft-use-filter-string-for-filename t
        deft-text-mode 'org-mode))
#+END_SRC
*** More Configuration from Brent

**** 18.7.6 Searching and showing results
Org-mode's searching capabilities are really effective at finding data in your org files. C-c / /
does a regular expression search on the current file and shows matching results in a collapsed view
of the org-file.


I have org-mode show the hierarchy of tasks above the matched entries and also the immediately
following sibling task (but not all siblings) with the following settings:
#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-show-following-heading t)
(setq org-show-hierarchy-above t)
(setq org-show-siblings (quote ((default))))
#+END_SRC
This keeps the results of the search relatively compact and mitigates accidental errors by cutting
too much data from your org file with C-k. Cutting folded data (including the …) can be really
dangerous since it cuts text (including following subtrees) which you can't see. For this reason I
always show the following headline when displaying search results.


**** 18.7.7 Editing and Special key handling
Org-mode allows special handling of the C-a, C-e, and C-k keys while editing headlines. I also use
the setting that pastes (yanks) subtrees and adjusts the levels to match the task I am pasting to.
See the docstring (C-h v org-yank-adjust-subtrees) for more details on each variable and what it
does.

I have org-special-ctrl-a/e set to enable easy access to the beginning and end of headlines. I use
M-m or C-a C-a to get to the beginning of the line so the speed commands work and C-a to give easy
access to the beginning of the heading text when I need that.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-special-ctrl-a/e t)
(setq org-special-ctrl-k t)
(setq org-yank-adjusted-subtrees t)
#+END_SRC
**** Speed Commands
There's an exciting feature called org-speed-commands in the org-mode.

Speed commands allow access to frequently used commands when on the beginning of a headline -
similar to one-key agenda commands. Speed commands are user configurable and org-mode provides a
good set of default commands.


I have the following speed commands set up in addition to the defaults. I don't use priorities so I
override the default settings for the 1, 2, and 3 keys. I also disable cycling with 'c' and add 'q'
as a quick way to get back to the agenda and update the current view.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-use-speed-commands t)
(setq org-speed-commands-user (quote (("0" . ignore)
                                      ("1" . ignore)
                                      ("2" . ignore)
                                      ("3" . ignore)
                                      ("4" . ignore)
                                      ("5" . ignore)
                                      ("6" . ignore)
                                      ("7" . ignore)
                                      ("8" . ignore)
                                      ("9" . ignore)

                                      ("a" . ignore)
                                      ("d" . ignore)
                                      ("h" . bh/hide-other)
                                      ("i" progn
                                       (forward-char 1)
                                       (call-interactively 'org-insert-heading-respect-content))
                                      ("k" . org-kill-note-or-show-branches)
                                      ("l" . ignore)
                                      ("m" . ignore)
                                      ("q" . bh/show-org-agenda)
                                      ("r" . ignore)
                                      ("s" . org-save-all-org-buffers)
                                      ("w" . org-refile)
                                      ("x" . ignore)
                                      ("y" . ignore)
                                      ("z" . org-add-note)

                                      ("A" . ignore)
                                      ("B" . ignore)
                                      ("E" . ignore)
                                      ("F" . bh/restrict-to-file-or-follow)
                                      ("G" . ignore)
                                      ("H" . ignore)
                                      ("J" . org-clock-goto)
                                      ("K" . ignore)
                                      ("L" . ignore)
                                      ("M" . ignore)
                                      ("N" . bh/narrow-to-org-subtree)
                                      ("P" . bh/narrow-to-org-project)
                                      ("Q" . ignore)
                                      ("R" . ignore)
                                      ("S" . ignore)
                                      ("T" . bh/org-todo)
                                      ("U" . bh/narrow-up-one-org-level)
                                      ("V" . ignore)
                                      ("W" . bh/widen)
                                      ("X" . ignore)
                                      ("Y" . ignore)
                                      ("Z" . ignore))))

(defun bh/show-org-agenda ()
  (interactive)
  (if org-agenda-sticky
      (switch-to-buffer "*Org Agenda( )*")
    (switch-to-buffer "*Org Agenda*"))
  (delete-other-windows))
#+END_SRC

This requires setting up access to the calendar api
Follow these steps https://github.com/myuhe/org-gcal.el/blob/master/README.org
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-gcal
  :init
  (use-package request-deferred
    :ensure t)
  (use-package alert
    :ensure t)
  :config
  ;; (setq org-gcal-client-id "oauth client id"
  ;;       org-gcal-client-secret "client secret"
  ;;       org-gcal-file-alist '(("calendar email" . "gcal.org")
  ;;                             ("another calendar email" . "workgcal.org")))
  )
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package calfw
  :ensure t
  :init
  (use-package calfw-org
    :ensure t)
  (use-package calfw-ical
    :ensure t)
  :config
  (require 'calfw)
  (require 'calfw-org)
  (setq cfw:org-overwrite-default-keybinding t)
  (require 'calfw-ical)

  (defun mycalendar ()
    (interactive)
    (cfw:open-calendar-buffer
     :contents-sources
     (list
      (cfw:org-create-source "Green")  ; orgmode source
      ;;(cfw:ical-create-source "gcal" "some public ical address" "IndianRed")
      ;;(cfw:ical-create-source "gcal" "another public ical address" "IndianRed")
      )))
  (setq cfw:org-overwrite-default-keybinding t))

(use-package calfw-gcal
  :ensure t
  :config
  (require 'calfw-gcal))
#+END_SRC
**** Turn off debug
#+BEGIN_SRC emacs-lisp :tangle yes
(setq debug-on-error nil)
(setq debug-on-quit nil)
#+END_SRC
** Eshell
Tweaking the eshell to give'em ehell
#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/setup-eshell ()
  (interactive)
  ;; turn off semantic-mode in eshell buffers Needed?
  (semantic-mode -1)

  (local-set-key (kbd "M-P") 'eshell-previous-prompt)
  (local-set-key (kbd "M-N") 'eshell-next-prompt)
  (local-set-key (kbd "M-R") 'eshell-previous-matching-input))
#+END_SRC

A nice helper to sudo-edit a file
#+BEGIN_SRC emacs-lisp :tangle yes
(defun sudoec (file)
  (interactive)
  (find-file (concat "/sudo::" (expand-file-name file))))
#+END_SRC

Setup some nice settings for eshell
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package eshell
  :commands (eshell eshell-command)
  :bind ("C-c m" . eshell)
  :init
  (require 'em-smart)
  (setq eshell-glob-case-insensitive nil
        eshell-error-if-no-glob nil
        eshell-scroll-to-bottom-on-input nil
        eshell-where-to-jump 'begin
        eshell-review-quick-commands nil
        eshell-smart-space-goes-to-end t)
  ;; Initialize "smart" mode
  ;;(add-hook 'eshell-mode-hook #'eshell-smart-initialize)
  :config
  (defalias 'emacs 'find-file)
  (defalias 'hff 'hexl-find-file)
  (defalias 'sec 'sudoec)
  (setenv "PAGER" "cat")
  (use-package esh-opt
    :config
    (use-package em-cmpl)
    (use-package em-prompt
      :init
      (with-eval-after-load 'em-prompt
        (defun eshell-next-prompt (n)
          "Move to end of Nth next prompt in the buffer. See `eshell-prompt-regexp'."
          (interactive "p")
          (re-search-forward eshell-prompt-regexp nil t n)
          (when eshell-highlight-prompt
          (while (not (get-text-property (line-beginning-position) 'read-only))
            (re-search-forward eshell-prompt-regexp nil t n)))
          (eshell-skip-prompt))

        (defun eshell-previous-prompt (n)
          "Move to end of Nth previous prompt in the buffer. See `eshell-prompt-regexp'."
          (interactive "p")
          (backward-char)
          (eshell-next-prompt (- n)))))
    (use-package em-term)

    ;; Shared history.
    (defvar eshell-history-global-ring nil
      "The history ring shared across Eshell sessions.")

    ;; (defun eshell-hist-use-global-history ()
    ;;   "Make Eshell history shared across different sessions."
    ;;   (unless eshell-history-global-ring
    ;;     (let (eshell-history-ring)
    ;;       (when eshell-history-file-name
    ;;         (eshell-read-history nil t))
    ;;       (setq eshell-history-global-ring eshell-history-ring))
    ;;     (unless eshell-history-ring (setq eshell-history-global-ring (make-ring eshell-history-size))))
    ;;   (setq eshell-history-ring eshell-history-global-ring))
    ;; (add-hook 'eshell-mode-hook 'eshell-hist-use-global-history)

    (setq eshell-cmpl-cycle-completions nil
          ;; auto truncate after 12k lines
          eshell-buffer-maximum-lines 12000
          ;; history size
          eshell-history-size 500
          ;; buffer shorthand -> echo foo > #'buffer
          eshell-buffer-shorthand t
          ;; my prompt is easy enough to see
          eshell-highlight-prompt nil
          ;; treat 'echo' like shell echo
          eshell-plain-echo-behavior t
          ;; add -lh to the `ls' flags
          eshell-ls-initial-args "-lh")

    ;; Visual commands
    (setq eshell-visual-commands '("vi" "screen" "top" "less" "more" "lynx"
                                   "ncftp" "pine" "tin" "trn" "elm" "vim"
                                   "nmtui" "alsamixer" "htop" "el" "elinks"
                                   "ssh" "nethack" "dtop" "dstat"))
    (setq eshell-visual-subcommands '(("git" "log" "diff" "show")
                                      ("vagrant" "ssh")))

    (defun my/truncate-eshell-buffers ()
      "Truncates all eshell buffers"
      (interactive)
      (save-current-buffer
        (dolist (buffer (buffer-list t))
          (set-buffer buffer)
          (when (eq major-mode 'eshell-mode)
            (eshell-truncate-buffer)))))

    ;; After being idle for 5 seconds, truncate all the eshell-buffers if
    ;; needed. If this needs to be canceled, you can run `(cancel-timer
    ;; my/eshell-truncate-timer)'
    (setq my/eshell-truncate-timer
          (run-with-idle-timer 5 t #'my/truncate-eshell-buffers))

    (defun eshell/cds ()
      "Change directory to the project's root."
      (eshell/cd (locate-dominating-file default-directory ".git")))

    (defalias 'eshell/l 'eshell/ls)
    (defalias 'eshell/ll 'eshell/ls)

    (defun eshell/ec (pattern)
      (if (stringp pattern)
          (find-file pattern)
        (mapc #'find-file (mapcar #'expand-file-name pattern))))
    (defalias 'e 'eshell/ec)
    (defalias 'ee 'find-file-other-window)

    (defun eshell/d (&rest args)
      (dired (pop args) "."))

    (defun eshell/clear ()
      "Clear the eshell buffer"
      (interactive)
      (let ((eshell-buffer-maximum-lines 0))
        (eshell-truncate-buffer)
        (let ((inhibit-read-only t))
          (erase-buffer)
          (eshell-send-input)))))

  (defun eshell/icat (&rest args)
    "Display image(s)."
    (let ((elems (eshell-flatten-list args)))
      (while elems
        (eshell-printn
         (propertize " "
                     'display (create-image (expand-file-name (car elems)))))
        (setq elems (cdr elems))))
    nil)

  (add-hook 'eshell-mode-hook #'my/setup-eshell)

  ;; See eshell-prompt-function below
  (setq eshell-prompt-regexp "^[^#$\n]* [#$] ")

  ;; So the history vars are defined
  (require 'em-hist)
  (if (boundp 'eshell-save-history-on-exit)
      ;; Don't ask, just save
      (setq eshell-save-history-on-exit t))

  ;; See: https://github.com/kaihaosw/eshell-prompt-extras
  (use-package eshell-prompt-extras
    :ensure t
    :init
    (progn
      (setq eshell-highlight-prompt nil
            epe-git-dirty-char " Ϟ"
            ;; epe-git-dirty-char "*"
            eshell-prompt-function 'epe-theme-dakrone)))

  (defun eshell/magit ()
    "Function to open magit-status for the current directory"
    (interactive)
    (magit-status default-directory)
    nil))

  (use-package esh-autosuggest
    :ensure t
    :hook (eshell-mode . esh-autosuggest-mode))
#+END_SRC

Create eshell buffers with the press of a button
#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/create-or-switch-to-delta-buffer ()
  "Switch to the *eshell delta* buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell-delta*")
      (switch-to-buffer "*eshell-delta*")
    (let ((eshell-buffer-name "*eshell-delta*"))
      (eshell))))

(global-set-key (kbd "C-x d") 'my/create-or-switch-to-delta-buffer)

(defun my/create-or-switch-to-eshell-1 ()
  "Switch to the *eshell* buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell*")
      (switch-to-buffer "*eshell*")
    (let ((eshell-buffer-name "*eshell*"))
      (eshell))))

(defun my/create-or-switch-to-eshell-2 ()
  "Switch to the *eshell*<2> buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell*<2>")
      (switch-to-buffer "*eshell*<2>")
    (let ((eshell-buffer-name "*eshell*<2>"))
      (eshell))))

(defun my/create-or-switch-to-eshell-3 ()
  "Switch to the *eshell*<3> buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell*<3>")
      (switch-to-buffer "*eshell*<3>")
    (let ((eshell-buffer-name "*eshell*<3>"))
      (eshell))))

(defun my/create-or-switch-to-eshell-4 ()
  "Switch to the *eshell*<4> buffer, or create it"
  (interactive)
  (if (get-buffer "*eshell*<4>")
      (switch-to-buffer "*eshell*<4>")
    (let ((eshell-buffer-name "*eshell*<4>"))
      (eshell))))

(defun my/create-all-eshell-buffers ()
  "Create all my normal eshell buffers"
  (interactive)
  (let ((eshell-buffer-name "*eshell*")
        (default-directory "~/"))
    (eshell))
  (let ((eshell-buffer-name "*eshell*<2>")
        (default-directory "~/")) (eshell))
  (let ((eshell-buffer-name "*eshell*<3>")
        (default-directory "~/gitrepo"))
    (eshell))
  (let ((eshell-buffer-name "*eshell-delta*")
        (default-directory "~/.emacs.d"))
    (eshell))
  (let ((eshell-buffer-name "*eshell downloads*")
        (default-directory "~/Downloads"))
    (eshell)))

(global-set-key (kbd "M-@") #'my/create-all-eshell-buffers)

(global-set-key (kbd "H-1") 'my/create-or-switch-to-eshell-1)
(global-set-key (kbd "H-2") 'my/create-or-switch-to-eshell-2)
(global-set-key (kbd "H-3") 'my/create-or-switch-to-eshell-3)
(global-set-key (kbd "H-4") 'my/create-or-switch-to-eshell-4)
(global-set-key (kbd "s-1") 'my/create-or-switch-to-eshell-1)
(global-set-key (kbd "s-2") 'my/create-or-switch-to-eshell-2)
(global-set-key (kbd "s-3") 'my/create-or-switch-to-eshell-3)
(global-set-key (kbd "s-4") 'my/create-or-switch-to-eshell-4)
(global-set-key (kbd "M-1") 'my/create-or-switch-to-eshell-1)
(global-set-key (kbd "M-2") 'my/create-or-switch-to-eshell-2)
(global-set-key (kbd "M-3") 'my/create-or-switch-to-eshell-3)
(global-set-key (kbd "M-4") 'my/create-or-switch-to-eshell-4)
#+END_SRC

Open an eshell window in the current directory of the open buffer
#+BEGIN_SRC emacs-lisp :tangle yes
(defun eshell-here ()
  "Opens up a new shell in the directory associated with the
current buffer's file. The eshell is renamed to match that
directory to make multiple eshell windows easier."
  (interactive)
  (let* ((parent (if (buffer-file-name)
                     (file-name-directory (buffer-file-name))
                   default-directory))
         (height (/ (window-total-height) 3))
         (name   (car (last (split-string parent "/" t)))))
    (split-window-vertically (- height))
    (other-window 1)
    (eshell "new")
    (rename-buffer (concat "*eshell: " name "*"))

    (insert (concat "ls"))
    (eshell-send-input)))

(global-set-key (kbd "C-!") #'eshell-here)
#+END_SRC

Quickly close eshell window
#+BEGIN_SRC emacs-lisp :tangle yes
(defun eshell/x ()
  "Closes the EShell session and gets rid of the EShell window."
   (delete-window)
   (eshell/exit))
#+END_SRC
** Hooks
Run some things when everything is loaded.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'after-emacs-hook
          (lambda ()
            (message "Emacs has loaded")))

(defun my/time-since-start ()
  (float-time (time-subtract (current-time)
                             emacs-start-time)))

(add-hook 'after-emacs-hook
          `(lambda ()
             (let ((elapsed (my/time-since-start)))
               (message "Loading %s...done (%.3fs)"
                        ,load-file-name elapsed))) t)
(add-hook 'after-init-hook
          `(lambda ()
             (let ((elapsed (my/time-since-start)))
               (message "Loading %s...done (%.3fs) [after-init]"
                        ,load-file-name elapsed))) t)
(run-hooks 'after-emacs-hook)
(bh/org-agenda-to-appt)
#+END_SRC
